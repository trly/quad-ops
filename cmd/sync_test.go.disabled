package cmd

import (
	"context"
	"errors"
	"os"
	"testing"

	"github.com/benbjohnson/clock"
	"github.com/compose-spec/compose-go/v2/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/trly/quad-ops/internal/compose"
	"github.com/trly/quad-ops/internal/config"
	"github.com/trly/quad-ops/internal/git"
	"github.com/trly/quad-ops/internal/testutil"
)

// MockGitRepository for testing.
type MockGitRepository struct {
	SyncRepositoryFunc func() error
	HasChangesFunc     func() (bool, error)
}

func (m *MockGitRepository) SyncRepository() error {
	if m.SyncRepositoryFunc != nil {
		return m.SyncRepositoryFunc()
	}
	return nil
}

func (m *MockGitRepository) HasChanges() (bool, error) {
	if m.HasChangesFunc != nil {
		return m.HasChangesFunc()
	}
	return false, nil
}

// MockProcessor for testing.
type MockProcessor struct {
	ProcessProjectsFunc func(projects []*types.Project, processedUnits map[string]bool) error
}

func (m *MockProcessor) ProcessProjects(projects []*types.Project, processedUnits map[string]bool) error {
	if m.ProcessProjectsFunc != nil {
		return m.ProcessProjectsFunc(projects, processedUnits)
	}
	return nil
}

// TestSyncCommand_ValidationFailure tests system requirements failure.
func TestSyncCommand_ValidationFailure(t *testing.T) {
	app := NewAppBuilder(t).
		WithValidator(&MockValidator{
			SystemRequirementsFunc: func() error {
				return errors.New("systemd not found")
			},
		}).
		Build(t)

	cmd := NewSyncCommand().GetCobraCommand()
	SetupCommandContext(cmd, app)

	// PreRunE returns error instead of exiting
	err := cmd.PreRunE(cmd, []string{})
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "systemd not found")
}

// TestSyncCommand_DirectoryCreationFailure tests quadlet directory creation failure.
func TestSyncCommand_DirectoryCreationFailure(t *testing.T) {
	deps := SyncDeps{
		CommonDeps: CommonDeps{
			Clock: clock.NewMock(),
			FileSystem: FileSystemOps{
				MkdirAll: func(_ string, _ os.FileMode) error {
					return errors.New("permission denied")
				},
			},
			Logger: testutil.NewTestLogger(t),
		},
	}

	app := NewAppBuilder(t).Build(t)
	syncCmd := NewSyncCommand()
	opts := SyncOptions{}

	err := syncCmd.Run(context.Background(), app, opts, deps)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "permission denied")
}

// TestSyncCommand_Success tests successful sync operation.
func TestSyncCommand_Success(t *testing.T) {
	var gitSyncCalled bool
	var hasChangesCalled bool

	deps := SyncDeps{
		CommonDeps: CommonDeps{
			Clock: clock.NewMock(),
			FileSystem: FileSystemOps{
				MkdirAll: func(_ string, _ os.FileMode) error { return nil },
			},
			Logger: testutil.NewTestLogger(t),
		},
		NewGitRepository: func(_ config.Repository, _ config.Provider) *git.Repository {
			return &MockGitRepository{
				SyncRepositoryFunc: func() error {
					gitSyncCalled = true
					return nil
				},
				HasChangesFunc: func() (bool, error) {
					hasChangesCalled = true
					return true, nil
				},
			}
		},
		ReadProjects: func(_ string) ([]*types.Project, error) {
			return []*types.Project{
				{Name: "test-project"},
			}, nil
		},
		NewDefaultProcessor: func(_ bool) *compose.Processor {
			return &MockProcessor{}
		},
	}

	app := NewAppBuilder(t).
		WithConfig(&config.Settings{
			QuadletDir: "/tmp/test-quadlets",
			CacheDir:   "/tmp/test-cache",
			Repositories: []config.Repository{
				{Name: "test-repo"},
			},
		}).
		Build(t)

	syncCmd := NewSyncCommand()
	opts := SyncOptions{
		DryRun: false,
		Force:  false,
	}

	err := syncCmd.Run(context.Background(), app, opts, deps)
	assert.NoError(t, err)
	assert.True(t, gitSyncCalled)
	assert.True(t, hasChangesCalled)
}

// TestSyncCommand_DryRun tests dry run mode.
func TestSyncCommand_DryRun(t *testing.T) {
	var gitSyncCalled bool

	deps := SyncDeps{
		CommonDeps: CommonDeps{
			Clock: clock.NewMock(),
			FileSystem: FileSystemOps{
				MkdirAll: func(_ string, _ os.FileMode) error { return nil },
			},
			Logger: testutil.NewTestLogger(t),
		},
		NewGitRepository: func(_ config.Repository, _ config.Provider) *git.Repository {
			return &MockGitRepository{
				SyncRepositoryFunc: func() error {
					gitSyncCalled = true
					return nil
				},
			}
		},
	}

	app := NewAppBuilder(t).
		WithConfig(&config.Settings{
			Repositories: []config.Repository{
				{Name: "test-repo"},
			},
		}).
		Build(t)

	syncCmd := NewSyncCommand()
	opts := SyncOptions{
		DryRun: true, // Dry run mode
	}

	err := syncCmd.Run(context.Background(), app, opts, deps)
	assert.NoError(t, err)
	assert.False(t, gitSyncCalled, "Git sync should not be called in dry run mode")
}

// TestSyncCommand_NoChanges tests behavior when repository has no changes.
func TestSyncCommand_NoChanges(t *testing.T) {
	var readProjectsCalled bool

	deps := SyncDeps{
		CommonDeps: CommonDeps{
			Clock: clock.NewMock(),
			FileSystem: FileSystemOps{
				MkdirAll: func(_ string, _ os.FileMode) error { return nil },
			},
			Logger: testutil.NewTestLogger(t),
		},
		NewGitRepository: func(_ config.Repository, _ config.Provider) *git.Repository {
			return &MockGitRepository{
				SyncRepositoryFunc: func() error { return nil },
				HasChangesFunc: func() (bool, error) {
					return false, nil // No changes
				},
			}
		},
		ReadProjects: func(_ string) ([]*types.Project, error) {
			readProjectsCalled = true
			return []*types.Project{}, nil
		},
	}

	app := NewAppBuilder(t).
		WithConfig(&config.Settings{
			Repositories: []config.Repository{
				{Name: "test-repo"},
			},
		}).
		Build(t)

	syncCmd := NewSyncCommand()
	opts := SyncOptions{
		Force: false, // Don't force sync
	}

	err := syncCmd.Run(context.Background(), app, opts, deps)
	assert.NoError(t, err)
	assert.False(t, readProjectsCalled, "ReadProjects should be skipped when no changes")
}

// TestSyncCommand_RepoFilter tests repository filtering.
func TestSyncCommand_RepoFilter(t *testing.T) {
	var processedRepos []string

	deps := SyncDeps{
		CommonDeps: CommonDeps{
			Clock: clock.NewMock(),
			FileSystem: FileSystemOps{
				MkdirAll: func(_ string, _ os.FileMode) error { return nil },
			},
			Logger: testutil.NewTestLogger(t),
		},
		NewGitRepository: func(repo config.Repository, _ config.Provider) *git.Repository {
			return &MockGitRepository{
				SyncRepositoryFunc: func() error {
					processedRepos = append(processedRepos, repo.Name)
					return nil
				},
				HasChangesFunc: func() (bool, error) { return true, nil },
			}
		},
		ReadProjects: func(_ string) ([]*types.Project, error) {
			return []*types.Project{}, nil
		},
		NewDefaultProcessor: func(_ bool) *compose.Processor {
			return &MockProcessor{}
		},
	}

	app := NewAppBuilder(t).
		WithConfig(&config.Settings{
			CacheDir: "/tmp/test-cache",
			Repositories: []config.Repository{
				{Name: "repo1"},
				{Name: "repo2"},
				{Name: "repo3"},
			},
		}).
		Build(t)

	syncCmd := NewSyncCommand()
	opts := SyncOptions{
		RepoName: "repo2", // Filter to specific repo
	}

	err := syncCmd.Run(context.Background(), app, opts, deps)
	assert.NoError(t, err)
	assert.Equal(t, []string{"repo2"}, processedRepos, "Only specified repo should be processed")
}

// TestSyncCommand_Help tests help output.
func TestSyncCommand_Help(t *testing.T) {
	cmd := NewSyncCommand().GetCobraCommand()
	output, err := ExecuteCommandWithCapture(t, cmd, []string{"--help"})

	require.NoError(t, err)
	assert.Contains(t, output, "Synchronizes the Docker Compose files")
	assert.Contains(t, output, "--dry-run")
	assert.Contains(t, output, "--repo")
	assert.Contains(t, output, "--force")
}

// TestSyncCommand_Flags tests command-specific flags.
func TestSyncCommand_Flags(t *testing.T) {
	cmd := NewSyncCommand().GetCobraCommand()

	// Test dry-run flag
	dryRunFlag := cmd.Flags().Lookup("dry-run")
	require.NotNil(t, dryRunFlag)
	assert.Equal(t, "false", dryRunFlag.DefValue)

	// Test repo flag
	repoFlag := cmd.Flags().Lookup("repo")
	require.NotNil(t, repoFlag)
	assert.Equal(t, "", repoFlag.DefValue)

	// Test force flag
	forceFlag := cmd.Flags().Lookup("force")
	require.NotNil(t, forceFlag)
	assert.Equal(t, "false", forceFlag.DefValue)
}
