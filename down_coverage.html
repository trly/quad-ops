
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/trly/quad-ops/cmd/app.go (33.9%)</option>
				
				<option value="file1">github.com/trly/quad-ops/cmd/artifact_helpers.go (36.4%)</option>
				
				<option value="file2">github.com/trly/quad-ops/cmd/config.go (0.0%)</option>
				
				<option value="file3">github.com/trly/quad-ops/cmd/daemon.go (0.0%)</option>
				
				<option value="file4">github.com/trly/quad-ops/cmd/daemon_nonlinux.go (0.0%)</option>
				
				<option value="file5">github.com/trly/quad-ops/cmd/deps.go (25.0%)</option>
				
				<option value="file6">github.com/trly/quad-ops/cmd/doctor.go (0.0%)</option>
				
				<option value="file7">github.com/trly/quad-ops/cmd/down.go (96.1%)</option>
				
				<option value="file8">github.com/trly/quad-ops/cmd/image.go (0.0%)</option>
				
				<option value="file9">github.com/trly/quad-ops/cmd/image_pull.go (0.0%)</option>
				
				<option value="file10">github.com/trly/quad-ops/cmd/output.go (0.0%)</option>
				
				<option value="file11">github.com/trly/quad-ops/cmd/root.go (0.0%)</option>
				
				<option value="file12">github.com/trly/quad-ops/cmd/sync.go (0.0%)</option>
				
				<option value="file13">github.com/trly/quad-ops/cmd/test_helpers.go (69.2%)</option>
				
				<option value="file14">github.com/trly/quad-ops/cmd/unit.go (0.0%)</option>
				
				<option value="file15">github.com/trly/quad-ops/cmd/unit_list.go (0.0%)</option>
				
				<option value="file16">github.com/trly/quad-ops/cmd/unit_show.go (0.0%)</option>
				
				<option value="file17">github.com/trly/quad-ops/cmd/unit_status.go (0.0%)</option>
				
				<option value="file18">github.com/trly/quad-ops/cmd/up.go (0.0%)</option>
				
				<option value="file19">github.com/trly/quad-ops/cmd/update.go (0.0%)</option>
				
				<option value="file20">github.com/trly/quad-ops/cmd/validate.go (0.0%)</option>
				
				<option value="file21">github.com/trly/quad-ops/cmd/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package cmd provides the command line interface for quad-ops
package cmd

import (
        "context"
        "fmt"
        "runtime"
        "sync"

        "github.com/trly/quad-ops/internal/compose"
        "github.com/trly/quad-ops/internal/config"
        "github.com/trly/quad-ops/internal/execx"
        "github.com/trly/quad-ops/internal/fs"
        "github.com/trly/quad-ops/internal/log"
        "github.com/trly/quad-ops/internal/platform/launchd"
        platsystemd "github.com/trly/quad-ops/internal/platform/systemd"
        "github.com/trly/quad-ops/internal/repository"
        "github.com/trly/quad-ops/internal/systemd"
        "github.com/trly/quad-ops/internal/validate"
)

// UnsupportedPlatformError is returned when a platform-specific feature is not available.
type UnsupportedPlatformError struct {
        Platform string
        Feature  string
}

func (e *UnsupportedPlatformError) Error() string <span class="cov0" title="0">{
        if e.Feature != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s is not supported on %s - quad-ops requires Linux (systemd) or macOS (launchd) for service management. Non-platform commands (version, validate) work on all platforms.", e.Feature, e.Platform)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("platform %s is not supported - quad-ops requires Linux (systemd) or macOS (launchd) for service management. Non-platform commands (version, validate) work on all platforms.", e.Platform)</span>
}

// App holds the application dependencies for command line interface.
type App struct {
        Logger         log.Logger
        Config         *config.Settings
        ConfigProvider config.Provider
        Runner         execx.Runner
        FSService      *fs.Service

        // Phase 6: New architecture components (non-platform)
        ArtifactStore    repository.ArtifactStore  // Stores platform artifacts
        GitSyncer        repository.GitSyncer      // Syncs git repositories
        ComposeProcessor ComposeProcessorInterface // Processes compose to service specs

        // Platform-specific components (lazy initialization)
        platformOnce sync.Once
        renderer     RendererInterface
        lifecycle    LifecycleInterface
        platformErr  error
        os           string // For testing, defaults to runtime.GOOS

        Validator    SystemValidator
        OutputFormat string
}

// NewApp creates a new App with all dependencies initialized.
// Platform-specific components (Renderer, Lifecycle) are initialized lazily on first use.
func NewApp(logger log.Logger, configProv config.Provider) (*App, error) <span class="cov0" title="0">{
        cfg := configProv.GetConfig()
        runner := execx.NewRealRunner()
        fsService := fs.NewServiceWithLogger(configProv, logger)

        // New architecture components (platform-independent)
        // Determine artifact store base directory based on platform
        artifactBaseDir := cfg.QuadletDir
        if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                launchdOpts := launchd.DefaultOptions()
                artifactBaseDir = launchdOpts.PlistDir // ~/Library/LaunchAgents or /Library/LaunchDaemons
        }</span>
        <span class="cov0" title="0">artifactStore := repository.NewArtifactStore(fsService, logger, artifactBaseDir)
        gitSyncer := repository.NewGitSyncer(configProv, logger)
        composeProcessor := newComposeProcessor(cfg)

        // Create validator with injected dependencies
        validator := validate.NewValidator(logger, runner)

        return &amp;App{
                Logger:         logger,
                Config:         cfg,
                ConfigProvider: configProv,
                Runner:         runner,
                FSService:      fsService,

                // New architecture components (platform-independent)
                ArtifactStore:    artifactStore,
                GitSyncer:        gitSyncer,
                ComposeProcessor: composeProcessor,

                // Platform components initialized lazily
                os: runtime.GOOS,

                Validator: validator,
        }, nil</span>
}

// initPlatform initializes platform-specific components (renderer, lifecycle).
// Uses sync.Once to ensure initialization happens only once.
// For testing, checks if renderer/lifecycle are already injected before initializing.
func (a *App) initPlatform() <span class="cov8" title="1">{
        a.platformOnce.Do(func() </span><span class="cov8" title="1">{
                // If renderer and lifecycle are already set (test injection), skip initialization
                if a.renderer != nil &amp;&amp; a.lifecycle != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">targetOS := a.os
                if targetOS == "" </span><span class="cov8" title="1">{
                        targetOS = runtime.GOOS
                }</span>

                <span class="cov8" title="1">switch targetOS </span>{
                case "linux":<span class="cov0" title="0">
                        // Systemd platform
                        a.Logger.Debug("Initializing platform: systemd (Linux)")

                        // Create systemd factory for platform components
                        systemdFactory := systemd.NewDefaultFactory(a.ConfigProvider, a.Logger)

                        // Initialize renderer
                        a.renderer = platsystemd.NewRenderer(a.Logger)

                        // Initialize lifecycle
                        unitManager := systemdFactory.GetUnitManager()
                        connectionFactory := systemdFactory.GetConnectionFactory()
                        a.lifecycle = platsystemd.NewLifecycle(unitManager, connectionFactory, a.Config.UserMode, a.Logger)</span>

                case "darwin":<span class="cov8" title="1">
                        // Launchd platform (macOS)
                        a.Logger.Debug("Initializing platform: launchd (macOS)")

                        // Create launchd options
                        launchdOpts := launchd.DefaultOptions()

                        // Initialize renderer
                        renderer, err := launchd.NewRenderer(launchdOpts, a.Logger)
                        if err != nil </span><span class="cov0" title="0">{
                                a.platformErr = fmt.Errorf("failed to create launchd renderer: %w", err)
                                return
                        }</span>
                        <span class="cov8" title="1">a.renderer = renderer

                        // Initialize lifecycle
                        lifecycle, err := launchd.NewLifecycle(launchdOpts, a.Runner, a.Logger)
                        if err != nil </span><span class="cov0" title="0">{
                                a.platformErr = fmt.Errorf("failed to create launchd lifecycle: %w", err)
                                return
                        }</span>
                        <span class="cov8" title="1">a.lifecycle = lifecycle</span>

                default:<span class="cov0" title="0">
                        a.platformErr = &amp;UnsupportedPlatformError{
                                Platform: targetOS,
                                Feature:  "service management",
                        }</span>
                }
        })
}

// GetRenderer returns the platform renderer, initializing it if necessary.
func (a *App) GetRenderer(_ context.Context) (RendererInterface, error) <span class="cov0" title="0">{
        // If renderer is already set (test injection), return it directly
        if a.renderer != nil </span><span class="cov0" title="0">{
                return a.renderer, nil
        }</span>

        <span class="cov0" title="0">a.initPlatform()
        if a.platformErr != nil </span><span class="cov0" title="0">{
                return nil, a.platformErr
        }</span>
        <span class="cov0" title="0">return a.renderer, nil</span>
}

// GetLifecycle returns the platform lifecycle manager, initializing it if necessary.
func (a *App) GetLifecycle(_ context.Context) (LifecycleInterface, error) <span class="cov8" title="1">{
        // If lifecycle is already set (test injection), return it directly
        if a.lifecycle != nil </span><span class="cov8" title="1">{
                return a.lifecycle, nil
        }</span>

        <span class="cov8" title="1">a.initPlatform()
        if a.platformErr != nil </span><span class="cov0" title="0">{
                return nil, a.platformErr
        }</span>
        <span class="cov8" title="1">return a.lifecycle, nil</span>
}

// IsPlatformAvailable returns true if platform-specific features are available.
func (a *App) IsPlatformAvailable() bool <span class="cov0" title="0">{
        a.initPlatform()
        return a.platformErr == nil
}</span>

// newComposeProcessor creates a new compose processor with the repository directory.
func newComposeProcessor(cfg *config.Settings) ComposeProcessorInterface <span class="cov0" title="0">{
        return compose.NewSpecProcessor(cfg.RepositoryDir)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// Package cmd provides artifact helper functions for cross-platform support
package cmd

import (
        "path/filepath"
        "strings"
)

// parseServiceNameFromArtifact extracts the service name from an artifact path
// in a platform-neutral way.
//
// For systemd/quadlet artifacts (.container, .network, .volume, .build):
//   - "web-service-container.container" -&gt; "web-service"
//   - "web-service-network.network" -&gt; "web-service"
//   - "api.container" -&gt; "api"
//
// For launchd artifacts (.plist):
//   - "com.example.web-service.plist" -&gt; "web-service"
//   - "com.github.trly.api.plist" -&gt; "api"
//   - "simple.plist" -&gt; "simple"
func parseServiceNameFromArtifact(path string) string <span class="cov8" title="1">{
        base := filepath.Base(path)
        ext := filepath.Ext(base)
        name := strings.TrimSuffix(base, ext)

        if ext == ".plist" </span><span class="cov0" title="0">{
                // For launchd plists, extract the service name after the last dot
                // Label format is typically: &lt;prefix&gt;.&lt;serviceName&gt;
                // e.g., "com.example.web-service" -&gt; "web-service"
                if idx := strings.LastIndex(name, "."); idx &gt;= 0 </span><span class="cov0" title="0">{
                        return name[idx+1:]
                }</span>
                <span class="cov0" title="0">return name</span>
        }

        // For systemd/quadlet, strip common suffixes
        <span class="cov8" title="1">suffixes := []string{"-container", "-network", "-volume", "-build"}
        for _, suffix := range suffixes </span><span class="cov8" title="1">{
                if strings.HasSuffix(name, suffix) </span><span class="cov8" title="1">{
                        return strings.TrimSuffix(name, suffix)
                }</span>
        }

        <span class="cov0" title="0">return name</span>
}

// isServiceArtifact determines if an artifact represents a service
// that can be started/stopped (as opposed to networks, volumes, etc.).
//
// Returns true for:
//   - .container files (systemd/quadlet)
//   - .plist files (launchd)
func isServiceArtifact(path string) bool <span class="cov0" title="0">{
        ext := filepath.Ext(path)
        return ext == ".container" || ext == ".plist"
}</span>

// matchesServiceName checks if an artifact path matches the given service name.
// Handles both systemd and launchd naming conventions.
//
// For systemd: direct base name match
//   - "web-service.container" matches "web-service"
//
// For launchd: suffix-based match for labels
//   - "com.example.web-service.plist" matches "web-service"
func matchesServiceName(artifactPath, serviceName string) bool <span class="cov0" title="0">{
        base := filepath.Base(artifactPath)
        ext := filepath.Ext(base)
        name := strings.TrimSuffix(base, ext)

        // Direct match
        if name == serviceName </span><span class="cov0" title="0">{
                return true
        }</span>

        // For .plist files, check if the name ends with ".&lt;serviceName&gt;"
        <span class="cov0" title="0">if ext == ".plist" &amp;&amp; strings.HasSuffix(name, "."+serviceName) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"

        "github.com/trly/quad-ops/internal/config"
)

// ConfigCommand represents the config command for quad-ops CLI.
type ConfigCommand struct{}

// NewConfigCommand creates a new ConfigCommand.
func NewConfigCommand() *ConfigCommand <span class="cov0" title="0">{
        return &amp;ConfigCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *ConfigCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for config operations.
func (c *ConfigCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "config",
                Short: "Display current configuration",
                Long:  "Display the current configuration including defaults and overrides",
                Run: func(cmd *cobra.Command, _ []string) </span><span class="cov0" title="0">{
                        // Try to get config from app context first, fall back to global cfg
                        var config *config.Settings
                        if app := c.getApp(cmd); app != nil </span><span class="cov0" title="0">{
                                config = app.Config
                        }</span> else<span class="cov0" title="0"> {
                                config = cfg
                        }</span>

                        <span class="cov0" title="0">output, err := yaml.Marshal(config)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error marshalling config: %v\n", err)
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Println(string(output))</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"
        "runtime"
        "sync/atomic"
        "time"

        "github.com/spf13/cobra"
)

// DaemonOptions holds daemon command options.
type DaemonOptions struct {
        SyncInterval time.Duration
        RepoName     string
        Force        bool
}

// SyncRunner defines the interface for performing sync operations.
type SyncRunner interface {
        Run(context.Context, *App, SyncOptions, SyncDeps) error
        buildDeps(*App) SyncDeps
}

// DaemonDeps holds daemon dependencies.
type DaemonDeps struct {
        CommonDeps
        Notify      NotifyFunc
        SyncCommand SyncRunner
}

// DaemonCommand represents the daemon command for quad-ops CLI.
type DaemonCommand struct{}

// NewDaemonCommand creates a new DaemonCommand.
func NewDaemonCommand() *DaemonCommand <span class="cov0" title="0">{
        return &amp;DaemonCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *DaemonCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for daemon operations.
func (c *DaemonCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts DaemonOptions

        daemonCmd := &amp;cobra.Command{
                Use:   "daemon",
                Short: "Run quad-ops as a daemon with periodic synchronization",
                Long: `Run quad-ops as a daemon with periodic synchronization of configured repositories.

The daemon will perform initial synchronization and then continue running, 
periodically syncing repositories at the specified interval. This is ideal 
for continuous deployment scenarios where you want automatic updates.

On Linux, the daemon integrates with systemd, sending readiness and watchdog 
notifications when running under systemd supervision. On macOS, the daemon runs 
without systemd integration.`,
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">daemonCmd.Flags().DurationVarP(&amp;opts.SyncInterval, "sync-interval", "i", 5*time.Minute, "Interval between synchronization checks")
        daemonCmd.Flags().StringVarP(&amp;opts.RepoName, "repo", "r", "", "Synchronize a single, named, repository")
        daemonCmd.Flags().BoolVarP(&amp;opts.Force, "force", "f", false, "Force synchronization even if repository has not changed")

        return daemonCmd</span>
}

// buildDeps creates production dependencies for the daemon.
func (c *DaemonCommand) buildDeps(app *App) DaemonDeps <span class="cov0" title="0">{
        // Use platform-specific notify function
        var notifyFunc NotifyFunc
        if runtime.GOOS == "linux" </span><span class="cov0" title="0">{
                // Use systemd notifications on Linux
                notifyFunc = sdNotify
        }</span> else<span class="cov0" title="0"> {
                // No-op notifier on other platforms
                notifyFunc = func(_ bool, _ string) (bool, error) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return DaemonDeps{
                CommonDeps:  NewRootDeps(app),
                Notify:      notifyFunc,
                SyncCommand: NewSyncCommand(),
        }</span>
}

// Run executes the daemon with injected dependencies.
func (c *DaemonCommand) Run(ctx context.Context, app *App, opts DaemonOptions, deps DaemonDeps) error <span class="cov0" title="0">{
        // Ensure quadlet directory exists
        if err := deps.FileSystem.MkdirAll(app.Config.QuadletDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create quadlet directory: %w", err)
        }</span>

        // Override sync interval if specified
        <span class="cov0" title="0">if opts.SyncInterval &gt; 0 </span><span class="cov0" title="0">{
                app.Config.SyncInterval = opts.SyncInterval
        }</span>

        // Build sync dependencies once
        <span class="cov0" title="0">syncDeps := deps.SyncCommand.buildDeps(app)

        // Prepare sync options from daemon flags
        syncOpts := SyncOptions{
                RepoName: opts.RepoName,
                Force:    opts.Force,
                DryRun:   false,
        }

        // Perform initial sync
        if app.Config.Verbose </span><span class="cov0" title="0">{
                deps.Logger.Info("Performing initial sync")
        }</span>

        <span class="cov0" title="0">if err := deps.SyncCommand.Run(ctx, app, syncOpts, syncDeps); err != nil </span><span class="cov0" title="0">{
                deps.Logger.Error("Initial sync failed", "error", err)
                // Continue to daemon mode even if initial sync fails
        }</span>

        // Start daemon mode
        <span class="cov0" title="0">return c.runDaemon(ctx, app, syncOpts, deps, syncDeps)</span>
}

// runDaemon starts the daemon loop with periodic sync operations.
func (c *DaemonCommand) runDaemon(ctx context.Context, app *App, syncOpts SyncOptions, deps DaemonDeps, syncDeps SyncDeps) error <span class="cov0" title="0">{
        deps.Logger.Info("Starting sync daemon", "interval", app.Config.SyncInterval)

        // Notify systemd that the daemon is ready (no-op on non-Linux)
        if sent, err := deps.Notify(false, SdNotifyReady); err != nil </span><span class="cov0" title="0">{
                deps.Logger.Warn("Failed to notify systemd of readiness", "error", err)
        }</span> else<span class="cov0" title="0"> if sent </span><span class="cov0" title="0">{
                deps.Logger.Info("Notified systemd that daemon is ready")
        }</span>

        // Atomic guard to prevent overlapping syncs
        <span class="cov0" title="0">var syncing atomic.Bool

        // Backoff state for repeated failures
        consecutiveFailures := 0
        maxBackoffInterval := 30 * time.Minute
        baseInterval := app.Config.SyncInterval

        ticker := deps.Clock.Ticker(baseInterval)
        defer ticker.Stop()

        // Send periodic watchdog notifications if configured
        watchdogTicker := deps.Clock.Ticker(30 * time.Second)
        defer watchdogTicker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        deps.Logger.Info("Daemon context cancelled, shutting down")
                        return ctx.Err()</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Use atomic guard to prevent overlapping syncs
                        if !syncing.CompareAndSwap(false, true) </span><span class="cov0" title="0">{
                                deps.Logger.Warn("Previous sync still running, skipping this interval")
                                continue</span>
                        }

                        // Perform sync in current goroutine (blocking)
                        <span class="cov0" title="0">deps.Logger.Debug("Starting scheduled sync")
                        err := deps.SyncCommand.Run(ctx, app, syncOpts, syncDeps)

                        // Release sync lock
                        syncing.Store(false)

                        if err != nil </span><span class="cov0" title="0">{
                                consecutiveFailures++
                                deps.Logger.Error("Sync failed", "error", err, "consecutive_failures", consecutiveFailures)

                                // Apply exponential backoff on repeated failures
                                if consecutiveFailures &gt; 1 </span><span class="cov0" title="0">{
                                        // Calculate 2^(n-1), with bounds checking to prevent overflow
                                        exponent := consecutiveFailures - 1
                                        if exponent &gt; 30 </span><span class="cov0" title="0">{ // Prevent overflow beyond 2^30
                                                exponent = 30
                                        }</span>
                                        <span class="cov0" title="0">backoffMultiplier := 1 &lt;&lt; exponent // 2^(n-1)
                                        newInterval := baseInterval * time.Duration(backoffMultiplier)
                                        if newInterval &gt; maxBackoffInterval </span><span class="cov0" title="0">{
                                                newInterval = maxBackoffInterval
                                        }</span>

                                        <span class="cov0" title="0">deps.Logger.Warn("Applying backoff after repeated failures",
                                                "consecutive_failures", consecutiveFailures,
                                                "new_interval", newInterval)

                                        // Reset ticker with new interval
                                        ticker.Reset(newInterval)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // Sync succeeded - reset failure counter and interval
                                if consecutiveFailures &gt; 0 </span><span class="cov0" title="0">{
                                        deps.Logger.Info("Sync succeeded after failures, resetting interval",
                                                "previous_failures", consecutiveFailures)
                                        consecutiveFailures = 0
                                        ticker.Reset(baseInterval)
                                }</span>
                        }

                case &lt;-watchdogTicker.C:<span class="cov0" title="0">
                        // Send watchdog notification to systemd (no-op on non-Linux)
                        if sent, err := deps.Notify(false, SdNotifyWatchdog); err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Debug("Failed to send watchdog notification", "error", err)
                        }</span> else<span class="cov0" title="0"> if sent </span><span class="cov0" title="0">{
                                deps.Logger.Debug("Sent watchdog notification to systemd")
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:build !linux

/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

package cmd

// sdNotify is a no-op on non-Linux platforms.
func sdNotify(_ bool, _ string) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

// Systemd notification constants (no-op on non-Linux).
const (
        SdNotifyReady    = "READY=1"
        SdNotifyWatchdog = "WATCHDOG=1"
)
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "io/fs"
        "os"

        "github.com/benbjohnson/clock"
        "github.com/trly/quad-ops/internal/log"
)

// FileSystem defines the interface for file system operations.
type FileSystem interface {
        Stat(string) (fs.FileInfo, error)
        WriteFile(string, []byte, fs.FileMode) error
        Remove(string) error
        MkdirAll(string, fs.FileMode) error
}

// FileSystemOps provides file system operations for dependency injection.
type FileSystemOps struct {
        // Keep public fields for test compatibility
        StatFunc      func(string) (fs.FileInfo, error)
        WriteFileFunc func(string, []byte, fs.FileMode) error
        RemoveFunc    func(string) error
        MkdirAllFunc  func(string, fs.FileMode) error
}

// Stat returns file information for the given path.
func (f *FileSystemOps) Stat(path string) (fs.FileInfo, error) <span class="cov0" title="0">{
        if f.StatFunc != nil </span><span class="cov0" title="0">{
                return f.StatFunc(path)
        }</span>
        <span class="cov0" title="0">return os.Stat(path)</span>
}

// WriteFile writes data to the given path with specified permissions.
func (f *FileSystemOps) WriteFile(path string, data []byte, perm fs.FileMode) error <span class="cov0" title="0">{
        if f.WriteFileFunc != nil </span><span class="cov0" title="0">{
                return f.WriteFileFunc(path, data, perm)
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, perm)</span>
}

// Remove deletes the file at the given path.
func (f *FileSystemOps) Remove(path string) error <span class="cov0" title="0">{
        if f.RemoveFunc != nil </span><span class="cov0" title="0">{
                return f.RemoveFunc(path)
        }</span>
        <span class="cov0" title="0">return os.Remove(path)</span>
}

// MkdirAll creates directories with the given path and permissions.
func (f *FileSystemOps) MkdirAll(path string, perm fs.FileMode) error <span class="cov0" title="0">{
        if f.MkdirAllFunc != nil </span><span class="cov0" title="0">{
                return f.MkdirAllFunc(path, perm)
        }</span>
        <span class="cov0" title="0">return os.MkdirAll(path, perm)</span>
}

// Ensure FileSystemOps implements FileSystem.
var _ FileSystem = (*FileSystemOps)(nil)

// NewFileSystemOps returns production file system operations.
func NewFileSystemOps() FileSystemOps <span class="cov8" title="1">{
        // Return empty struct - methods will use OS functions as defaults
        return FileSystemOps{}
}</span>

// NotifyFunc represents systemd notification function.
type NotifyFunc func(unsetEnvironment bool, state string) (bool, error)

// CommonDeps provides dependencies common across commands.
type CommonDeps struct {
        Clock      clock.Clock
        FileSystem FileSystem
        Logger     log.Logger
}

// NewCommonDeps creates production common dependencies.
func NewCommonDeps(logger log.Logger) CommonDeps <span class="cov8" title="1">{
        fs := NewFileSystemOps()
        return CommonDeps{
                Clock:      clock.New(),
                FileSystem: &amp;fs,
                Logger:     logger,
        }
}</span>

// NewRootDeps creates common root dependencies for all commands.
// This helper reduces duplication in buildDeps methods.
func NewRootDeps(app *App) CommonDeps <span class="cov8" title="1">{
        return NewCommonDeps(app.Logger)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "github.com/trly/quad-ops/internal/config"
        "github.com/trly/quad-ops/internal/git"
)

// DoctorOptions holds doctor command options.
type DoctorOptions struct {
        // Currently no specific options for doctor command
}

// DoctorDeps holds doctor dependencies.
type DoctorDeps struct {
        CommonDeps
        NewGitRepo      func(config.Repository, config.Provider) *git.Repository
        ViperConfigFile func() string
        GetOS           func() string
}

// DoctorCommand represents the doctor command for quad-ops CLI.
type DoctorCommand struct{}

// NewDoctorCommand creates a new DoctorCommand.
func NewDoctorCommand() *DoctorCommand <span class="cov0" title="0">{
        return &amp;DoctorCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *DoctorCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// CheckResult represents the result of a diagnostic check.
type CheckResult struct {
        Name        string
        Passed      bool
        Message     string
        Suggestions []string
}

// GetCobraCommand returns the cobra command for doctor operations.
func (c *DoctorCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts DoctorOptions

        doctorCmd := &amp;cobra.Command{
                Use:   "doctor",
                Short: "Check system health and configuration",
                Long: `Check system health and configuration for quad-ops.

The doctor command performs comprehensive checks of:
- System requirements (systemd/podman on Linux, launchd/podman on macOS)
- Configuration file validity
- Directory permissions and accessibility
- Repository connectivity
- File system requirements

This helps diagnose common setup and configuration issues.`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">return doctorCmd</span>
}

// buildDeps creates production dependencies for the doctor command.
func (c *DoctorCommand) buildDeps(app *App) DoctorDeps <span class="cov0" title="0">{
        return DoctorDeps{
                CommonDeps:      NewRootDeps(app),
                NewGitRepo:      git.NewGitRepository,
                ViperConfigFile: func() string </span><span class="cov0" title="0">{ return viper.GetViper().ConfigFileUsed() }</span>,
                GetOS:           func() string <span class="cov0" title="0">{ return runtime.GOOS }</span>,
        }
}

// Run executes the doctor command with injected dependencies.
func (c *DoctorCommand) Run(_ context.Context, app *App, _ DoctorOptions, deps DoctorDeps) error <span class="cov0" title="0">{
        // Collect all diagnostic results
        var results []CheckResult
        var failureCount int

        // Run all checks
        results = append(results, c.checkSystemRequirements(app, deps)...)
        results = append(results, c.checkConfiguration(app, deps)...)
        results = append(results, c.checkDirectories(app, deps)...)
        results = append(results, c.checkRepositories(app, deps)...)

        // Count failures
        for _, result := range results </span><span class="cov0" title="0">{
                if !result.Passed </span><span class="cov0" title="0">{
                        failureCount++
                }</span>
        }

        // Display results based on output format
        <span class="cov0" title="0">if app.OutputFormat == "text" </span><span class="cov0" title="0">{
                // Traditional text output
                if app.Config.Verbose </span><span class="cov0" title="0">{
                        c.displayDetailedResults(results)
                }</span> else<span class="cov0" title="0"> {
                        c.displaySummaryResults(results)
                }</span>

                // Return error instead of exiting
                <span class="cov0" title="0">if failureCount &gt; 0 </span><span class="cov0" title="0">{
                        if !app.Config.Verbose </span><span class="cov0" title="0">{
                                fmt.Printf("\n%d checks failed. Run with --verbose for details.\n", failureCount)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("doctor found %d issues", failureCount)</span>
                } else<span class="cov0" title="0"> if app.Config.Verbose </span><span class="cov0" title="0">{
                        fmt.Println("\n✓ All checks passed")
                }</span>
        } else<span class="cov0" title="0"> {
                // Structured output (JSON/YAML)
                c.outputStructuredResults(app, results, failureCount)
                if failureCount &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("doctor found %d issues", failureCount)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// checkSystemRequirements validates core system dependencies.
func (c *DoctorCommand) checkSystemRequirements(app *App, deps DoctorDeps) []CheckResult <span class="cov0" title="0">{
        var results []CheckResult

        // Check platform-specific requirements
        err := app.Validator.SystemRequirements()
        if err != nil </span><span class="cov0" title="0">{
                // Platform-specific suggestions
                var suggestions []string
                platform := deps.GetOS()

                switch platform </span>{
                case "linux":<span class="cov0" title="0">
                        suggestions = []string{
                                "Install systemd if running on a systemd-based system",
                                "Install podman for container operations",
                                "Ensure systemd and podman are in your PATH",
                        }</span>
                case "darwin":<span class="cov0" title="0">
                        suggestions = []string{
                                "Install podman via Podman Desktop (https://podman-desktop.io) or Homebrew (brew install podman)",
                                "Ensure podman is in your PATH",
                                "launchd is built-in on macOS and should be available by default",
                        }</span>
                default:<span class="cov0" title="0">
                        suggestions = []string{
                                "quad-ops requires Linux (systemd) or macOS (launchd) for service management",
                        }</span>
                }

                <span class="cov0" title="0">results = append(results, CheckResult{
                        Name:        "System Requirements",
                        Passed:      false,
                        Message:     err.Error(),
                        Suggestions: suggestions,
                })</span>
        } else<span class="cov0" title="0"> {
                // Platform-specific success message
                var message string
                platform := deps.GetOS()

                switch platform </span>{
                case "linux":<span class="cov0" title="0">
                        message = "systemd and podman are available"</span>
                case "darwin":<span class="cov0" title="0">
                        message = "launchd and podman are available"</span>
                default:<span class="cov0" title="0">
                        message = "platform requirements met"</span>
                }

                <span class="cov0" title="0">results = append(results, CheckResult{
                        Name:    "System Requirements",
                        Passed:  true,
                        Message: message,
                })</span>
        }

        <span class="cov0" title="0">return results</span>
}

// checkConfiguration validates configuration file and settings.
func (c *DoctorCommand) checkConfiguration(app *App, deps DoctorDeps) []CheckResult <span class="cov0" title="0">{
        var results []CheckResult

        // Check if config file exists and is readable
        configFile := deps.ViperConfigFile()
        if configFile == "" </span><span class="cov0" title="0">{
                results = append(results, CheckResult{
                        Name:    "Configuration File",
                        Passed:  false,
                        Message: "No configuration file found",
                        Suggestions: []string{
                                "Create a configuration file at ~/.config/quad-ops/config.yaml",
                                "Or specify config file path with --config flag",
                                "Run 'quad-ops config' to see current configuration",
                        },
                })
        }</span> else<span class="cov0" title="0"> {
                if _, err := deps.FileSystem.Stat(configFile); err != nil </span><span class="cov0" title="0">{
                        results = append(results, CheckResult{
                                Name:    "Configuration File",
                                Passed:  false,
                                Message: fmt.Sprintf("Configuration file not accessible: %v", err),
                                Suggestions: []string{
                                        "Check file permissions on " + configFile,
                                        "Verify the file path is correct",
                                },
                        })
                }</span> else<span class="cov0" title="0"> {
                        results = append(results, CheckResult{
                                Name:    "Configuration File",
                                Passed:  true,
                                Message: fmt.Sprintf("Configuration loaded from %s", configFile),
                        })
                }</span>
        }

        // Check if repositories are configured
        <span class="cov0" title="0">if len(app.Config.Repositories) == 0 </span><span class="cov0" title="0">{
                results = append(results, CheckResult{
                        Name:    "Repository Configuration",
                        Passed:  false,
                        Message: "No repositories configured",
                        Suggestions: []string{
                                "Add repository configurations to your config file",
                                "Each repository should specify name, url, and target branch",
                        },
                })
        }</span> else<span class="cov0" title="0"> {
                results = append(results, CheckResult{
                        Name:    "Repository Configuration",
                        Passed:  true,
                        Message: fmt.Sprintf("%d repositories configured", len(app.Config.Repositories)),
                })
        }</span>

        <span class="cov0" title="0">return results</span>
}

// checkDirectories validates directory permissions and accessibility.
func (c *DoctorCommand) checkDirectories(app *App, deps DoctorDeps) []CheckResult <span class="cov0" title="0">{
        var results []CheckResult

        // Check quadlet directory
        quadletDir := app.Config.QuadletDir
        if err := c.checkDirectory("Quadlet Directory", quadletDir, deps); err != nil </span><span class="cov0" title="0">{
                suggestions := []string{
                        fmt.Sprintf("Create directory: mkdir -p %s", quadletDir),
                        fmt.Sprintf("Fix permissions: chmod 755 %s", quadletDir),
                }
                results = append(results, CheckResult{
                        Name:        "Quadlet Directory",
                        Passed:      false,
                        Message:     err.Error(),
                        Suggestions: suggestions,
                })
        }</span> else<span class="cov0" title="0"> {
                results = append(results, CheckResult{
                        Name:    "Quadlet Directory",
                        Passed:  true,
                        Message: fmt.Sprintf("Directory accessible at %s", quadletDir),
                })
        }</span>

        // Check repository directory
        <span class="cov0" title="0">repoDir := app.Config.RepositoryDir
        if err := c.checkDirectory("Repository Directory", repoDir, deps); err != nil </span><span class="cov0" title="0">{
                suggestions := []string{
                        fmt.Sprintf("Create directory: mkdir -p %s", repoDir),
                        fmt.Sprintf("Fix permissions: chmod 755 %s", repoDir),
                }
                results = append(results, CheckResult{
                        Name:        "Repository Directory",
                        Passed:      false,
                        Message:     err.Error(),
                        Suggestions: suggestions,
                })
        }</span> else<span class="cov0" title="0"> {
                results = append(results, CheckResult{
                        Name:    "Repository Directory",
                        Passed:  true,
                        Message: fmt.Sprintf("Directory accessible at %s", repoDir),
                })
        }</span>

        <span class="cov0" title="0">return results</span>
}

// checkRepositories validates repository connectivity and accessibility.
func (c *DoctorCommand) checkRepositories(app *App, deps DoctorDeps) []CheckResult <span class="cov0" title="0">{
        results := make([]CheckResult, 0, len(app.Config.Repositories))

        for _, repoConfig := range app.Config.Repositories </span><span class="cov0" title="0">{
                gitRepo := deps.NewGitRepo(repoConfig, app.ConfigProvider)

                // Check if repository directory exists
                repoPath := gitRepo.Path
                if _, err := deps.FileSystem.Stat(repoPath); err != nil </span><span class="cov0" title="0">{
                        suggestions := []string{
                                "Run 'quad-ops sync' to clone repositories",
                                "Check network connectivity to repository URL",
                                "Verify git credentials if using private repositories",
                        }
                        results = append(results, CheckResult{
                                Name:        fmt.Sprintf("Repository: %s", repoConfig.Name),
                                Passed:      false,
                                Message:     fmt.Sprintf("Repository not cloned locally: %v", err),
                                Suggestions: suggestions,
                        })
                        continue</span>
                }

                // Check if it's a valid git repository
                <span class="cov0" title="0">if !c.isValidGitRepo(repoPath, deps) </span><span class="cov0" title="0">{
                        suggestions := []string{
                                fmt.Sprintf("Remove invalid directory: rm -rf %s", repoPath),
                                "Run 'quad-ops sync' to re-clone repository",
                        }
                        results = append(results, CheckResult{
                                Name:        fmt.Sprintf("Repository: %s", repoConfig.Name),
                                Passed:      false,
                                Message:     "Directory exists but is not a valid git repository",
                                Suggestions: suggestions,
                        })
                        continue</span>
                }

                // Check compose directory if specified
                <span class="cov0" title="0">if repoConfig.ComposeDir != "" </span><span class="cov0" title="0">{
                        composeDir := filepath.Join(repoPath, repoConfig.ComposeDir)
                        if _, err := deps.FileSystem.Stat(composeDir); err != nil </span><span class="cov0" title="0">{
                                suggestions := []string{
                                        fmt.Sprintf("Verify compose directory path in configuration: %s", repoConfig.ComposeDir),
                                        "Check if the directory exists in the repository",
                                }
                                results = append(results, CheckResult{
                                        Name:        fmt.Sprintf("Repository: %s", repoConfig.Name),
                                        Passed:      false,
                                        Message:     fmt.Sprintf("Compose directory not found: %s", repoConfig.ComposeDir),
                                        Suggestions: suggestions,
                                })
                                continue</span>
                        }
                }

                <span class="cov0" title="0">results = append(results, CheckResult{
                        Name:    fmt.Sprintf("Repository: %s", repoConfig.Name),
                        Passed:  true,
                        Message: fmt.Sprintf("Repository accessible at %s", repoPath),
                })</span>
        }

        <span class="cov0" title="0">return results</span>
}

// checkDirectory validates a directory exists and is accessible.
func (c *DoctorCommand) checkDirectory(_, path string, deps DoctorDeps) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("directory path is empty")
        }</span>

        // Check if directory exists
        <span class="cov0" title="0">stat, err := deps.FileSystem.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory does not exist: %s", path)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot access directory: %v", err)</span>
        }

        // Check if it's actually a directory
        <span class="cov0" title="0">if !stat.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("path exists but is not a directory: %s", path)
        }</span>

        // Check if directory is writable
        <span class="cov0" title="0">testFile := filepath.Join(path, ".quad-ops-test")
        if err := deps.FileSystem.WriteFile(testFile, []byte("test"), 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("directory is not writable: %v", err)
        }</span>
        <span class="cov0" title="0">if err := deps.FileSystem.Remove(testFile); err != nil </span><span class="cov0" title="0">{
                deps.Logger.Debug("Failed to cleanup test file", "file", testFile, "error", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isValidGitRepo checks if the given path contains a valid git repository.
func (c *DoctorCommand) isValidGitRepo(path string, deps DoctorDeps) bool <span class="cov0" title="0">{
        gitDir := filepath.Join(path, ".git")
        if stat, err := deps.FileSystem.Stat(gitDir); err != nil || !stat.IsDir() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// displaySummaryResults shows a brief summary of check results.
func (c *DoctorCommand) displaySummaryResults(results []CheckResult) <span class="cov0" title="0">{
        var failed []CheckResult

        for _, result := range results </span><span class="cov0" title="0">{
                if !result.Passed </span><span class="cov0" title="0">{
                        failed = append(failed, result)
                }</span>
        }

        <span class="cov0" title="0">if len(failed) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Issues found:")
                for _, result := range failed </span><span class="cov0" title="0">{
                        fmt.Printf("✗ %s: %s\n", result.Name, result.Message)
                }</span>
        }
}

// displayDetailedResults shows detailed information about all checks.
func (c *DoctorCommand) displayDetailedResults(results []CheckResult) <span class="cov0" title="0">{
        fmt.Println("System Health Check Results:")
        fmt.Println(strings.Repeat("=", 40))

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Passed </span><span class="cov0" title="0">{
                        fmt.Printf("✓ %s: %s\n", result.Name, result.Message)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✗ %s: %s\n", result.Name, result.Message)
                        if len(result.Suggestions) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Println("  Suggestions:")
                                for _, suggestion := range result.Suggestions </span><span class="cov0" title="0">{
                                        fmt.Printf("    - %s\n", suggestion)
                                }</span>
                        }
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }
}

// outputStructuredResults outputs health check results in structured format (JSON/YAML).
func (c *DoctorCommand) outputStructuredResults(app *App, results []CheckResult, failureCount int) <span class="cov0" title="0">{
        checks := make([]CheckResultStructured, 0, len(results))
        passedCount := 0

        for _, result := range results </span><span class="cov0" title="0">{
                status := "failed"
                if result.Passed </span><span class="cov0" title="0">{
                        status = "passed"
                        passedCount++
                }</span>

                <span class="cov0" title="0">checks = append(checks, CheckResultStructured{
                        Name:        result.Name,
                        Status:      status,
                        Message:     result.Message,
                        Suggestions: result.Suggestions,
                })</span>
        }

        <span class="cov0" title="0">overall := "passed"
        if failureCount &gt; 0 </span><span class="cov0" title="0">{
                overall = "failed"
        }</span>

        <span class="cov0" title="0">output := HealthCheckOutput{
                Overall: overall,
                Checks:  checks,
                Summary: map[string]int{
                        "total":  len(results),
                        "passed": passedCount,
                        "failed": failureCount,
                },
        }

        // Print structured output
        _ = PrintOutput(app.OutputFormat, output)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"

        "github.com/spf13/cobra"
)

// DownOptions holds down command options.
type DownOptions struct {
        Services []string
        All      bool
        Purge    bool
}

// DownDeps holds down dependencies.
type DownDeps struct {
        CommonDeps
        Lifecycle     LifecycleInterface
        ArtifactStore ArtifactStoreInterface
}

// DownCommand represents the down command for quad-ops CLI.
type DownCommand struct{}

// NewDownCommand creates a new DownCommand.
func NewDownCommand() *DownCommand <span class="cov8" title="1">{
        return &amp;DownCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *DownCommand) getApp(cmd *cobra.Command) *App <span class="cov8" title="1">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for stopping managed units.
func (c *DownCommand) GetCobraCommand() *cobra.Command <span class="cov8" title="1">{
        var opts DownOptions

        downCmd := &amp;cobra.Command{
                Use:   "down",
                Short: "Stop managed services",
                Long: `Stop managed services synchronized from repositories.

By default, stops all services. Use --services to specify which services to stop.
Use --purge to delete service artifacts from disk after stopping.

Examples:
  quad-ops down                              # Stop all services
  quad-ops down --services web-service       # Stop specific service
  quad-ops down --services web,api,db        # Stop multiple services
  quad-ops down --all --purge                # Stop all and delete artifacts`,
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov8" title="1">downCmd.Flags().StringSliceVarP(&amp;opts.Services, "services", "s", nil, "Comma-separated list of services to stop")
        downCmd.Flags().BoolVarP(&amp;opts.All, "all", "a", false, "Explicitly stop all services (default behavior)")
        downCmd.Flags().BoolVarP(&amp;opts.Purge, "purge", "p", false, "Delete service artifacts from disk after stopping")

        return downCmd</span>
}

// buildDeps creates production dependencies for the down command.
// Note: Platform-specific dependency (Lifecycle) is obtained via lazy getter in Run().
func (c *DownCommand) buildDeps(app *App) DownDeps <span class="cov8" title="1">{
        return DownDeps{
                CommonDeps:    NewRootDeps(app),
                Lifecycle:     nil, // Obtained via app.GetLifecycle(ctx) in Run()
                ArtifactStore: app.ArtifactStore,
        }
}</span>

// Run executes the down command with injected dependencies.
func (c *DownCommand) Run(ctx context.Context, app *App, opts DownOptions, deps DownDeps) error <span class="cov8" title="1">{
        // Get platform-specific component via lazy getter
        lifecycle, err := app.GetLifecycle(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("platform not supported: %w", err)
        }</span>
        <span class="cov8" title="1">deps.Lifecycle = lifecycle

        // 1. Determine target services
        var servicesToStop []string

        if len(opts.Services) &gt; 0 </span><span class="cov8" title="1">{
                // Use specified services
                servicesToStop = opts.Services
                deps.Logger.Debug("Stopping specified services", "services", servicesToStop)
        }</span> else<span class="cov8" title="1"> {
                // Query ArtifactStore for all services
                deps.Logger.Debug("Querying artifact store for all services")
                artifacts, err := deps.ArtifactStore.List(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to list artifacts: %w", err)
                }</span>

                <span class="cov8" title="1">if len(artifacts) == 0 </span><span class="cov8" title="1">{
                        deps.Logger.Info("No managed services found")
                        return nil
                }</span>

                // Extract service names from artifacts using platform-neutral helper
                <span class="cov8" title="1">serviceSet := make(map[string]bool)
                for _, artifact := range artifacts </span><span class="cov8" title="1">{
                        serviceName := parseServiceNameFromArtifact(artifact.Path)
                        if serviceName != "" </span><span class="cov8" title="1">{
                                serviceSet[serviceName] = true
                        }</span>
                }

                <span class="cov8" title="1">for serviceName := range serviceSet </span><span class="cov8" title="1">{
                        servicesToStop = append(servicesToStop, serviceName)
                }</span>

                <span class="cov8" title="1">deps.Logger.Debug("Found services from artifacts", "count", len(servicesToStop))</span>
        }

        <span class="cov8" title="1">if len(servicesToStop) == 0 </span><span class="cov0" title="0">{
                deps.Logger.Info("No services to stop")
                return nil
        }</span>

        // 2. Stop services using Lifecycle
        <span class="cov8" title="1">deps.Logger.Info("Stopping services", "count", len(servicesToStop))
        stopErrors := deps.Lifecycle.StopMany(ctx, servicesToStop)

        // Track failures
        failedServices := make([]string, 0)
        for serviceName, err := range stopErrors </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        deps.Logger.Error("Failed to stop service", "service", serviceName, "error", err)
                        failedServices = append(failedServices, serviceName)
                }</span> else<span class="cov8" title="1"> {
                        deps.Logger.Info("Service stopped", "service", serviceName)
                }</span>
        }

        // 3. Optional: Purge artifacts if requested
        <span class="cov8" title="1">if opts.Purge </span><span class="cov8" title="1">{
                deps.Logger.Info("Purging service artifacts")

                // List all artifacts to find paths to delete
                artifacts, err := deps.ArtifactStore.List(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to list artifacts for purge: %w", err)
                }</span>

                // Build list of artifact paths to delete
                <span class="cov8" title="1">pathsToDelete := make([]string, 0)
                for _, artifact := range artifacts </span><span class="cov8" title="1">{
                        // If --services specified, only delete artifacts for those services
                        if len(opts.Services) &gt; 0 </span><span class="cov8" title="1">{
                                serviceName := parseServiceNameFromArtifact(artifact.Path)
                                if c.shouldDeleteService(serviceName, opts.Services) </span><span class="cov8" title="1">{
                                        pathsToDelete = append(pathsToDelete, artifact.Path)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Delete all artifacts
                                pathsToDelete = append(pathsToDelete, artifact.Path)
                        }</span>
                }

                <span class="cov8" title="1">if len(pathsToDelete) &gt; 0 </span><span class="cov8" title="1">{
                        deps.Logger.Debug("Deleting artifacts", "count", len(pathsToDelete))
                        if err := deps.ArtifactStore.Delete(ctx, pathsToDelete); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to delete artifacts: %w", err)
                        }</span>

                        // Reload service manager after artifact deletion
                        <span class="cov8" title="1">deps.Logger.Debug("Reloading service manager after purge")
                        if err := deps.Lifecycle.Reload(ctx); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to reload service manager: %w", err)
                        }</span>

                        <span class="cov8" title="1">deps.Logger.Info("Artifacts purged", "count", len(pathsToDelete))</span>
                }
        }

        // Report overall status
        <span class="cov8" title="1">stoppedCount := len(servicesToStop) - len(failedServices)
        if len(failedServices) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to stop %d of %d services", len(failedServices), len(servicesToStop))
        }</span>

        <span class="cov8" title="1">deps.Logger.Info("Services stopped successfully", "count", stoppedCount)
        return nil</span>
}

// shouldDeleteService checks if a service should be deleted based on the services list.
func (c *DownCommand) shouldDeleteService(serviceName string, targetServices []string) bool <span class="cov8" title="1">{
        for _, target := range targetServices </span><span class="cov8" title="1">{
                if serviceName == target </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// Package cmd contains the command-line interface (CLI) for quad-ops.
package cmd

import (
        "github.com/spf13/cobra"
)

// ImageCommand represents the image command for quad-ops CLI.
type ImageCommand struct{}

// NewImageCommand creates a new ImageCommand.
func NewImageCommand() *ImageCommand <span class="cov0" title="0">{
        return &amp;ImageCommand{}
}</span>

// GetCobraCommand returns the cobra command for image operations.
func (c *ImageCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        imageCmd := &amp;cobra.Command{
                Use:   "image",
                Short: "subcommands for managing and viewing images for quad-ops managed services",
        }

        imageCmd.AddCommand(
                NewPullCommand().GetCobraCommand(),
        )

        return imageCmd
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

package cmd

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/compose"
        "github.com/trly/quad-ops/internal/git"
)

// PullOptions holds pull command options.
type PullOptions struct {
        // No flags currently supported
}

// PullDeps holds pull dependencies.
type PullDeps struct {
        CommonDeps
        ExecCommand func(name string, arg ...string) *exec.Cmd
        Environ     func() []string
        Getuid      func() int
}

// PullCommand represents the pull command.
type PullCommand struct{}

// NewPullCommand creates a new PullCommand.
func NewPullCommand() *PullCommand <span class="cov0" title="0">{
        return &amp;PullCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *PullCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand gets the cobra command.
func (c *PullCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts PullOptions

        pullCmd := &amp;cobra.Command{
                Use:   "pull",
                Short: "pull an image from a registry",
                Args:  cobra.MaximumNArgs(1),
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps, args)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">return pullCmd</span>
}

// buildDeps creates production dependencies for pull.
func (c *PullCommand) buildDeps(app *App) PullDeps <span class="cov0" title="0">{
        return PullDeps{
                CommonDeps:  NewRootDeps(app),
                ExecCommand: exec.Command,
                Environ:     os.Environ,
                Getuid:      os.Getuid,
        }
}</span>

// Run executes the pull command with injected dependencies.
func (c *PullCommand) Run(ctx context.Context, app *App, _ PullOptions, deps PullDeps, args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                for _, repoConfig := range app.Config.Repositories </span><span class="cov0" title="0">{
                        gitRepo := git.NewGitRepository(repoConfig, app.ConfigProvider)
                        composeDir := gitRepo.Path
                        if repoConfig.ComposeDir != "" </span><span class="cov0" title="0">{
                                composeDir = filepath.Join(gitRepo.Path, repoConfig.ComposeDir)
                        }</span>

                        <span class="cov0" title="0">projects, err := compose.ReadProjects(composeDir)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to read projects from repository", "name", repoConfig.Name, "composeDir", repoConfig.ComposeDir, "error", err)
                                deps.Logger.Info("Check that the composeDir path exists in the repository", "repository", repoConfig.Name, "expectedPath", repoConfig.ComposeDir)
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, project := range projects </span><span class="cov0" title="0">{
                                for _, service := range project.Services </span><span class="cov0" title="0">{
                                        if err := c.pullImage(ctx, app, deps, service.Image); err != nil </span><span class="cov0" title="0">{
                                                deps.Logger.Error("Failed to pull image", "image", service.Image, "error", err)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *PullCommand) pullImage(_ context.Context, app *App, deps PullDeps, image string) error <span class="cov0" title="0">{
        // Use podman pull directly - it handles rootless mode automatically
        args := []string{"pull"}

        // Always show progress for better user experience
        // Only add quiet flag if explicitly not verbose
        if !app.Config.Verbose </span><span class="cov0" title="0">{
                args = append(args, "--quiet")
        }</span>

        <span class="cov0" title="0">args = append(args, image)

        // Build command safely - podman is a known safe command
        cmd := deps.ExecCommand("podman", args...) // #nosec G204
        cmd.Cancel = func() error </span><span class="cov0" title="0">{
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        return cmd.Process.Kill()
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Set up environment for rootless operation
        <span class="cov0" title="0">if app.Config.UserMode </span><span class="cov0" title="0">{
                env := deps.Environ()
                // Ensure XDG_RUNTIME_DIR is set for rootless operation
                if os.Getenv("XDG_RUNTIME_DIR") == "" </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("XDG_RUNTIME_DIR=/run/user/%d", deps.Getuid()))
                }</span>
                <span class="cov0" title="0">cmd.Env = env</span>
        }

        // Show progress by connecting stdout/stderr to the current process
        <span class="cov0" title="0">if app.Config.Verbose </span><span class="cov0" title="0">{
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                deps.Logger.Info("Pulling image", "image", image)
        }</span> else<span class="cov0" title="0"> {
                // For non-verbose mode, still capture output for error reporting
                output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("podman pull failed: %w\nOutput: %s", err, strings.TrimSpace(string(output)))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Run the command and wait for completion
        <span class="cov0" title="0">err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("podman pull failed: %w", err)
        }</span>

        <span class="cov0" title="0">deps.Logger.Info("Successfully pulled image", "image", image)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package cmd provides output formatting utilities for quad-ops CLI.
package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// OutputData represents structured data that can be output in multiple formats.
type OutputData struct {
        Data interface{} `json:"data,omitempty" yaml:"data,omitempty"`
}

// PrintOutput formats and prints data according to the specified output format.
func PrintOutput(format string, data interface{}) error <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "json":<span class="cov0" title="0">
                return printJSON(data)</span>
        case "yaml", "yml":<span class="cov0" title="0">
                return printYAML(data)</span>
        case "text":<span class="cov0" title="0">
                return printText(data)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", format)</span>
        }
}

// printJSON outputs data as JSON.
func printJSON(data interface{}) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(data)
}</span>

// printYAML outputs data as YAML.
func printYAML(data interface{}) error <span class="cov0" title="0">{
        encoder := yaml.NewEncoder(os.Stdout)
        defer func() </span><span class="cov0" title="0">{
                _ = encoder.Close() // Ignore close error for stdout
        }</span>()
        <span class="cov0" title="0">return encoder.Encode(data)</span>
}

// printText outputs data in a human-readable text format.
func printText(data interface{}) error <span class="cov0" title="0">{
        // For text output, we expect the caller to handle formatting
        // This is a fallback that just prints the data
        fmt.Printf("%+v\n", data)
        return nil
}</span>

// OperationResult represents the result of an operation that can be output in structured format.
type OperationResult struct {
        Success bool              `json:"success" yaml:"success"`
        Message string            `json:"message,omitempty" yaml:"message,omitempty"`
        Items   []string          `json:"items,omitempty" yaml:"items,omitempty"`
        Errors  []string          `json:"errors,omitempty" yaml:"errors,omitempty"`
        Details map[string]string `json:"details,omitempty" yaml:"details,omitempty"`
}

// CheckResultStructured represents a health check result in structured format.
type CheckResultStructured struct {
        Name        string   `json:"name" yaml:"name"`
        Status      string   `json:"status" yaml:"status"`
        Message     string   `json:"message,omitempty" yaml:"message,omitempty"`
        Suggestions []string `json:"suggestions,omitempty" yaml:"suggestions,omitempty"`
}

// HealthCheckOutput represents the output of the doctor command.
type HealthCheckOutput struct {
        Overall string                  `json:"overall" yaml:"overall"`
        Checks  []CheckResultStructured `json:"checks" yaml:"checks"`
        Summary map[string]int          `json:"summary" yaml:"summary"`
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"
        "os"

        "github.com/trly/quad-ops/internal/config"
        "github.com/trly/quad-ops/internal/log"
        "github.com/trly/quad-ops/internal/sorting"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// contextKey is the type used for context keys to avoid collisions.
type contextKey string

// appContextKey is the context key for the App instance.
const appContextKey = contextKey("app")

// RootOptions holds root command options.
type RootOptions struct {
        UserMode       bool
        ConfigFilePath string
        QuadletDir     string
        RepositoryDir  string
        Verbose        bool
        OutputFormat   string
}

// RootDeps holds root dependencies.
type RootDeps struct {
        CommonDeps
        ValidatePath func(string) error
        ExpandEnv    func(string) string
}

// RootCommand represents the root command for quad-ops CLI.
type RootCommand struct{}

var (
        cfg *config.Settings
)

// GetCobraCommand returns the cobra root command for quad-ops CLI.
func (c *RootCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts RootOptions

        rootCmd := &amp;cobra.Command{
                Use:   "quad-ops",
                Short: "Quad-Ops manages Quadlet container units by synchronizing them from Git repositories.",
                Long: `Quad-Ops manages Quadlet container units by synchronizing them from Git repositories.
It automatically generates systemd unit files from Docker Compose files and handles unit reloading and restarting.`,
                PersistentPreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        deps := c.buildDeps()
                        return c.persistentPreRun(cmd, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">rootCmd.PersistentFlags().BoolVarP(&amp;opts.UserMode, "user", "u", false, "Run in user mode")
        rootCmd.PersistentFlags().BoolVarP(&amp;opts.Verbose, "verbose", "v", false, "Enable verbose logging")
        rootCmd.PersistentFlags().StringVar(&amp;opts.ConfigFilePath, "config", "", "Path to the configuration file")
        rootCmd.PersistentFlags().StringVar(&amp;opts.QuadletDir, "quadlet-dir", "", "Path to the quadlet directory")
        rootCmd.PersistentFlags().StringVar(&amp;opts.RepositoryDir, "repository-dir", "", "Path to the repository directory")
        rootCmd.PersistentFlags().StringVarP(&amp;opts.OutputFormat, "output", "o", "text", "Output format (text, json, yaml)")

        rootCmd.AddCommand(
                NewConfigCommand().GetCobraCommand(),
                NewSyncCommand().GetCobraCommand(),
                NewDaemonCommand().GetCobraCommand(),
                NewDoctorCommand().GetCobraCommand(),
                NewUnitCommand().GetCobraCommand(),
                NewUpCommand().GetCobraCommand(),
                NewImageCommand().GetCobraCommand(),
                NewDownCommand().GetCobraCommand(),
                NewUpdateCommand().GetCobraCommand(),
                NewValidateCommand().GetCobraCommand(),
                NewVersionCommand().GetCobraCommand(),
        )

        return rootCmd</span>
}

// buildDeps creates production dependencies for root.
func (c *RootCommand) buildDeps() RootDeps <span class="cov0" title="0">{
        return RootDeps{
                CommonDeps:   CommonDeps{}, // Will be initialized in persistentPreRun
                ValidatePath: sorting.ValidatePath,
                ExpandEnv:    os.ExpandEnv,
        }
}</span>

// persistentPreRun executes the persistent pre-run logic with injected dependencies.
func (c *RootCommand) persistentPreRun(cmd *cobra.Command, opts RootOptions, deps RootDeps) error <span class="cov0" title="0">{
        configProv := config.NewConfigProvider()
        cfg = configProv.GetConfig()
        logger := log.NewLogger(opts.Verbose)

        if opts.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("%s using config: %s\n\n", cmd.Root().Use, viper.GetViper().ConfigFileUsed())
                cfg.Verbose = opts.Verbose
        }</span>

        <span class="cov0" title="0">if opts.UserMode </span><span class="cov0" title="0">{
                cfg.UserMode = opts.UserMode
                cfg.RepositoryDir = deps.ExpandEnv(config.DefaultUserRepositoryDir)
                cfg.QuadletDir = deps.ExpandEnv(config.DefaultUserQuadletDir)
        }</span>

        <span class="cov0" title="0">if opts.RepositoryDir != "" </span><span class="cov0" title="0">{
                // Validate repository directory path
                if err := deps.ValidatePath(opts.RepositoryDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid repository directory %s: %w", opts.RepositoryDir, err)
                }</span>
                <span class="cov0" title="0">cfg.RepositoryDir = opts.RepositoryDir</span>
        }

        <span class="cov0" title="0">if opts.QuadletDir != "" </span><span class="cov0" title="0">{
                // Validate quadlet directory path
                if err := deps.ValidatePath(opts.QuadletDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid quadlet directory %s: %w", opts.QuadletDir, err)
                }</span>
                <span class="cov0" title="0">cfg.QuadletDir = opts.QuadletDir</span>
        }

        // Initialize app and store in context for commands that need it
        <span class="cov0" title="0">app, err := NewApp(logger, configProv)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize application: %w", err)
        }</span>
        <span class="cov0" title="0">app.OutputFormat = opts.OutputFormat
        cmd.SetContext(context.WithValue(cmd.Context(), appContextKey, app))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/compose"
        "github.com/trly/quad-ops/internal/config"
        "github.com/trly/quad-ops/internal/platform"
)

// SyncOptions holds sync command options.
type SyncOptions struct {
        DryRun   bool
        RepoName string
        Force    bool
}

// SyncDeps holds sync dependencies.
type SyncDeps struct {
        CommonDeps
        GitSyncer        GitSyncerInterface
        ComposeProcessor ComposeProcessorInterface
        Renderer         RendererInterface
        ArtifactStore    ArtifactStoreInterface
        Lifecycle        LifecycleInterface
}

// SyncCommand represents the sync command for quad-ops CLI.
type SyncCommand struct{}

// NewSyncCommand creates a new SyncCommand.
func NewSyncCommand() *SyncCommand <span class="cov0" title="0">{
        return &amp;SyncCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *SyncCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for sync operations.
func (c *SyncCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts SyncOptions

        syncCmd := &amp;cobra.Command{
                Use:   "sync",
                Short: "Synchronizes the Docker Compose files defined in configured repositories with quadlet units on the local system.",
                Long: `Synchronizes the Docker Compose files defined in configured repositories with quadlet units on the local system.

Repositories are defined in the quad-ops config file as a list of Repository objects.

---
repositories:
  - name: quad-ops-compose
    url: https://github.com/trly/quad-ops-compose.git
    target: main
    cleanup:
      action: Delete`,

                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">syncCmd.Flags().BoolVarP(&amp;opts.DryRun, "dry-run", "d", false, "Perform a dry run without making any changes.")
        syncCmd.Flags().StringVarP(&amp;opts.RepoName, "repo", "r", "", "Synchronize a single, named, repository.")
        syncCmd.Flags().BoolVarP(&amp;opts.Force, "force", "f", false, "Force synchronization even if the repository has not changed.")

        return syncCmd</span>
}

// buildDeps creates production dependencies for the sync command.
// Note: Platform-specific dependencies (Renderer, Lifecycle) are obtained via lazy getters in Run().
func (c *SyncCommand) buildDeps(app *App) SyncDeps <span class="cov0" title="0">{
        return SyncDeps{
                CommonDeps:       NewRootDeps(app),
                GitSyncer:        app.GitSyncer,
                ComposeProcessor: app.ComposeProcessor,
                Renderer:         nil, // Obtained via app.GetRenderer(ctx) in Run()
                ArtifactStore:    app.ArtifactStore,
                Lifecycle:        nil, // Obtained via app.GetLifecycle(ctx) in Run()
        }
}</span>

// Run executes the sync command with injected dependencies.
// This method orchestrates components directly following the new architecture pattern:
// GitSyncer → ComposeProcessor → Renderer → ArtifactStore → Lifecycle.
func (c *SyncCommand) Run(ctx context.Context, app *App, opts SyncOptions, deps SyncDeps) error <span class="cov0" title="0">{
        // Get platform-specific components via lazy getters
        renderer, err := app.GetRenderer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("platform not supported: %w", err)
        }</span>
        <span class="cov0" title="0">deps.Renderer = renderer

        lifecycle, err := app.GetLifecycle(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("platform not supported: %w", err)
        }</span>
        <span class="cov0" title="0">deps.Lifecycle = lifecycle

        // Ensure quadlet directory exists
        if err := deps.FileSystem.MkdirAll(app.Config.QuadletDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create quadlet directory: %w", err)
        }</span>

        // Handle dry-run mode early
        <span class="cov0" title="0">if opts.DryRun </span><span class="cov0" title="0">{
                deps.Logger.Info("Dry-run mode enabled - no changes will be made")
                return nil
        }</span>

        // 1. Sync git repositories
        <span class="cov0" title="0">deps.Logger.Debug("Syncing git repositories", "count", len(app.Config.Repositories))

        // Filter repositories if specific repo requested
        reposToSync := app.Config.Repositories
        if opts.RepoName != "" </span><span class="cov0" title="0">{
                reposToSync = make([]config.Repository, 0, 1)
                for _, repo := range app.Config.Repositories </span><span class="cov0" title="0">{
                        if repo.Name == opts.RepoName </span><span class="cov0" title="0">{
                                reposToSync = append(reposToSync, repo)
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(reposToSync) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("repository not found: %s", opts.RepoName)
                }</span>
        }

        <span class="cov0" title="0">results, err := deps.GitSyncer.SyncAll(ctx, reposToSync)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git sync failed: %w", err)
        }</span>

        // Track all services to restart
        <span class="cov0" title="0">servicesToRestart := make(map[string]bool)
        anyChanges := false

        // 2. Process each repository
        for _, result := range results </span><span class="cov0" title="0">{
                // Check for errors
                if result.Error != nil </span><span class="cov0" title="0">{
                        deps.Logger.Error("Repository sync failed", "repo", result.Repository.Name, "error", result.Error)
                        continue</span>
                }

                // Skip if no changes and not forced
                <span class="cov0" title="0">if !result.Changed &amp;&amp; !opts.Force </span><span class="cov0" title="0">{
                        deps.Logger.Debug("Repository unchanged, skipping", "repo", result.Repository.Name)
                        continue</span>
                }

                <span class="cov0" title="0">deps.Logger.Info("Processing repository", "repo", result.Repository.Name, "changed", result.Changed)

                // 3. Process compose files to service specs
                repoPath := filepath.Join(app.Config.RepositoryDir, result.Repository.Name)

                // Read compose files from repository
                projects, err := compose.ReadProjects(repoPath)
                if err != nil </span><span class="cov0" title="0">{
                        deps.Logger.Error("Failed to read compose projects", "repo", result.Repository.Name, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">if len(projects) == 0 </span><span class="cov0" title="0">{
                        deps.Logger.Debug("No compose projects found", "repo", result.Repository.Name)
                        continue</span>
                }

                // Process all compose projects to service specs
                <span class="cov0" title="0">for _, project := range projects </span><span class="cov0" title="0">{
                        specs, err := deps.ComposeProcessor.Process(ctx, project)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to process compose project",
                                        "repo", result.Repository.Name, "project", project.Name, "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">deps.Logger.Debug("Processed compose project",
                                "repo", result.Repository.Name, "project", project.Name, "services", len(specs))

                        // 4. Render to platform-specific artifacts
                        renderResult, err := deps.Renderer.Render(ctx, specs)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to render artifacts",
                                        "repo", result.Repository.Name, "project", project.Name, "error", err)
                                continue</span>
                        }

                        // 5. Write artifacts to disk (with change detection)
                        <span class="cov0" title="0">changedPaths, err := deps.ArtifactStore.Write(ctx, renderResult.Artifacts)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to write artifacts",
                                        "repo", result.Repository.Name, "project", project.Name, "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(changedPaths) &gt; 0 </span><span class="cov0" title="0">{
                                anyChanges = true
                                deps.Logger.Info("Artifacts written",
                                        "repo", result.Repository.Name, "project", project.Name, "changed", len(changedPaths))

                                // Track services that need restart
                                c.trackChangedServices(changedPaths, renderResult.ServiceChanges, opts.Force, servicesToRestart)
                        }</span> else<span class="cov0" title="0"> {
                                deps.Logger.Debug("No artifact changes", "repo", result.Repository.Name, "project", project.Name)
                        }</span>
                }
        }

        // 6. Reload service manager if any artifacts changed
        <span class="cov0" title="0">if anyChanges || opts.Force </span><span class="cov0" title="0">{
                deps.Logger.Info("Reloading service manager")
                if err := deps.Lifecycle.Reload(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reload service manager: %w", err)
                }</span>

                // 7. Restart changed services
                <span class="cov0" title="0">if len(servicesToRestart) &gt; 0 </span><span class="cov0" title="0">{
                        serviceNames := make([]string, 0, len(servicesToRestart))
                        for name := range servicesToRestart </span><span class="cov0" title="0">{
                                serviceNames = append(serviceNames, name)
                        }</span>

                        <span class="cov0" title="0">deps.Logger.Info("Restarting changed services", "count", len(serviceNames))

                        // Use RestartMany for dependency-aware restart
                        restartErrors := deps.Lifecycle.RestartMany(ctx, serviceNames)

                        // Log any restart failures
                        for serviceName, err := range restartErrors </span><span class="cov0" title="0">{
                                if err != nil </span><span class="cov0" title="0">{
                                        deps.Logger.Error("Failed to restart service", "service", serviceName, "error", err)
                                }</span> else<span class="cov0" title="0"> {
                                        deps.Logger.Info("Service restarted", "service", serviceName)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                deps.Logger.Info("No changes detected")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// trackChangedServices determines which services need restart based on changed artifact paths.
func (c *SyncCommand) trackChangedServices(changedPaths []string, serviceChanges map[string]platform.ChangeStatus, force bool, servicesToRestart map[string]bool) <span class="cov0" title="0">{
        changedPathSet := make(map[string]bool)
        for _, path := range changedPaths </span><span class="cov0" title="0">{
                changedPathSet[path] = true
        }</span>

        <span class="cov0" title="0">for serviceName, changeStatus := range serviceChanges </span><span class="cov0" title="0">{
                // Check if any of this service's artifacts changed
                serviceChanged := false
                for _, artifactPath := range changeStatus.ArtifactPaths </span><span class="cov0" title="0">{
                        if changedPathSet[artifactPath] </span><span class="cov0" title="0">{
                                serviceChanged = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if serviceChanged || force </span><span class="cov0" title="0">{
                        servicesToRestart[serviceName] = true
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "bytes"
        "context"
        "io"
        "os"
        "testing"

        "github.com/spf13/cobra"
        "github.com/stretchr/testify/assert"
)

// ExecuteCommandWithCapture executes a cobra command and captures all output (stdout/stderr).
// This handles both cmd.Print* and fmt.Print* outputs by redirecting os.Stdout/os.Stderr.
func ExecuteCommandWithCapture(t *testing.T, cmd *cobra.Command, args []string) (output string, err error) <span class="cov8" title="1">{
        t.Helper()

        // Capture stdout and stderr
        oldStdout := os.Stdout
        oldStderr := os.Stderr

        r, w, _ := os.Pipe()
        os.Stdout = w
        os.Stderr = w

        // Also set cobra's output (for cmd.Print* methods)
        var buf bytes.Buffer
        cmd.SetOut(&amp;buf)
        cmd.SetErr(&amp;buf)
        cmd.SetArgs(args)

        // Channel to capture output
        outputCh := make(chan string, 1)

        // Read from pipe in goroutine
        go func() </span><span class="cov8" title="1">{
                var output bytes.Buffer
                _, _ = io.Copy(&amp;output, r)
                outputCh &lt;- output.String()
        }</span>()

        // Execute command
        <span class="cov8" title="1">err = cmd.Execute()

        // Restore stdout/stderr
        _ = w.Close()
        os.Stdout = oldStdout
        os.Stderr = oldStderr

        // Get captured output
        capturedOutput := &lt;-outputCh

        // Combine both outputs (pipe capture + cobra buffer)
        combined := capturedOutput + buf.String()

        return combined, err</span>
}

// ExecuteCommand is a simpler helper for commands that don't need output capture.
func ExecuteCommand(t *testing.T, cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        t.Helper()
        cmd.SetArgs(args)
        return cmd.Execute()
}</span>

// AssertCommandSuccess verifies a command executed successfully.
func AssertCommandSuccess(t *testing.T, cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        t.Helper()
        err := ExecuteCommand(t, cmd, args)
        assert.NoError(t, err)
}</span>

// AssertCommandOutput verifies command output contains expected strings.
func AssertCommandOutput(t *testing.T, cmd *cobra.Command, args []string, expectedOutputs ...string) <span class="cov0" title="0">{
        t.Helper()
        output, err := ExecuteCommandWithCapture(t, cmd, args)
        assert.NoError(t, err)

        for _, expected := range expectedOutputs </span><span class="cov0" title="0">{
                assert.Contains(t, output, expected, "Expected output to contain: %s\nActual output: %s", expected, output)
        }</span>
}

// AssertCommandFailure verifies a command fails with expected error.
func AssertCommandFailure(t *testing.T, cmd *cobra.Command, args []string, expectedError string) <span class="cov0" title="0">{
        t.Helper()
        _, err := ExecuteCommandWithCapture(t, cmd, args)
        assert.Error(t, err)
        assert.Contains(t, err.Error(), expectedError)
}</span>

// SetupCommandContext creates a command with app context for testing.
func SetupCommandContext(cmd *cobra.Command, app *App) <span class="cov8" title="1">{
        ctx := context.WithValue(context.Background(), appContextKey, app)
        cmd.SetContext(ctx)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// Package cmd provides unit command functionality for quad-ops CLI
package cmd

import (
        "github.com/spf13/cobra"
)

// UnitCommand represents the unit command for quad-ops CLI.
type UnitCommand struct{}

// NewUnitCommand creates a new UnitCommand.
func NewUnitCommand() *UnitCommand <span class="cov0" title="0">{
        return &amp;UnitCommand{}
}</span>

// GetCobraCommand returns the cobra command for unit operations.
func (c *UnitCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        unitCmd := &amp;cobra.Command{
                Use:   "unit",
                Short: "subcommands for managing and viewing quadlet units",
        }

        unitCmd.AddCommand(
                NewShowCommand().GetCobraCommand(),
                NewListCommand().GetCobraCommand(),
                NewStatusCommand().GetCobraCommand(),
        )

        return unitCmd
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// Package cmd provides unit command functionality for quad-ops CLI
package cmd

import (
        "context"
        "fmt"
        "path/filepath"
        "strings"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/platform"
        "github.com/trly/quad-ops/internal/repository"
)

// ListOptions holds list command options.
type ListOptions struct {
        Status bool
}

// ListDeps holds list dependencies.
type ListDeps struct {
        CommonDeps
        ArtifactStore repository.ArtifactStore
}

// ListCommand represents the unit list command.
type ListCommand struct{}

// NewListCommand creates a new ListCommand.
func NewListCommand() *ListCommand <span class="cov0" title="0">{
        return &amp;ListCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *ListCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for listing units.
func (c *ListCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts ListOptions

        unitListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Lists artifacts currently managed by quad-ops",
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">unitListCmd.Flags().BoolVarP(&amp;opts.Status, "status", "s", false, "Include service status information")

        return unitListCmd</span>
}

// Run executes the list command with injected dependencies.
func (c *ListCommand) Run(ctx context.Context, app *App, opts ListOptions, deps ListDeps) error <span class="cov0" title="0">{
        // Fetch artifacts from ArtifactStore
        artifacts, err := deps.ArtifactStore.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list artifacts: %w", err)
        }</span>

        // Filter artifacts to only show services with com.github.trly prefix
        <span class="cov0" title="0">filteredArtifacts := make([]platform.Artifact, 0, len(artifacts))
        for _, artifact := range artifacts </span><span class="cov0" title="0">{
                base := filepath.Base(artifact.Path)
                if strings.Contains(base, "com.github.trly") </span><span class="cov0" title="0">{
                        filteredArtifacts = append(filteredArtifacts, artifact)
                }</span>
        }
        <span class="cov0" title="0">artifacts = filteredArtifacts

        if len(artifacts) == 0 </span><span class="cov0" title="0">{
                deps.Logger.Info("No artifacts found")
                return nil
        }</span>

        // Get lifecycle if status is requested
        <span class="cov0" title="0">var lifecycle platform.Lifecycle
        if opts.Status </span><span class="cov0" title="0">{
                lc, err := app.GetLifecycle(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get lifecycle: %w", err)
                }</span>
                <span class="cov0" title="0">lifecycle = lc</span>
        }

        // Setup table with appropriate columns
        <span class="cov0" title="0">headerFmt := color.New(color.FgGreen, color.Underline).SprintfFunc()
        columnFmt := color.New(color.FgYellow).SprintfFunc()

        var tbl table.Table
        if opts.Status </span><span class="cov0" title="0">{
                tbl = table.New("Path", "Type", "Hash", "Active", "State")
        }</span> else<span class="cov0" title="0"> {
                tbl = table.New("Path", "Type", "Hash")
        }</span>
        <span class="cov0" title="0">tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(columnFmt)

        // Display artifacts
        for _, artifact := range artifacts </span><span class="cov0" title="0">{
                hashStr := artifact.Hash
                if len(hashStr) &gt; 12 </span><span class="cov0" title="0">{
                        hashStr = hashStr[:12] // First 12 chars
                }</span>

                <span class="cov0" title="0">artifactType := extractArtifactType(artifact.Path)

                if opts.Status &amp;&amp; isServiceArtifact(artifact.Path) </span><span class="cov0" title="0">{
                        // Fetch status for service artifacts (.container on systemd, .plist on launchd)
                        serviceName := parseServiceNameFromArtifact(artifact.Path)
                        status, err := lifecycle.Status(ctx, serviceName)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Debug("Error getting service status", "service", serviceName, "error", err)
                                tbl.AddRow(artifact.Path, artifactType, hashStr, "UNKNOWN", "-")
                        }</span> else<span class="cov0" title="0"> {
                                activeState := "inactive"
                                if status.Active </span><span class="cov0" title="0">{
                                        activeState = "active"
                                }</span>
                                <span class="cov0" title="0">tbl.AddRow(artifact.Path, artifactType, hashStr, activeState, status.State)</span>
                        }
                } else<span class="cov0" title="0"> {
                        tbl.AddRow(artifact.Path, artifactType, hashStr)
                }</span>
        }

        <span class="cov0" title="0">tbl.Print()
        return nil</span>
}

// buildDeps creates production dependencies for the list command.
// Note: Lifecycle is obtained via lazy getter in Run() when status is requested.
func (c *ListCommand) buildDeps(app *App) ListDeps <span class="cov0" title="0">{
        return ListDeps{
                CommonDeps:    NewRootDeps(app),
                ArtifactStore: app.ArtifactStore,
        }
}</span>

// extractArtifactType extracts the type from an artifact path.
// E.g., "myservice.container" -&gt; "container", "com.example.svc.plist" -&gt; "plist".
func extractArtifactType(path string) string <span class="cov0" title="0">{
        ext := filepath.Ext(path)
        return strings.TrimPrefix(ext, ".")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// Package cmd provides unit command functionality for quad-ops CLI
package cmd

import (
        "context"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/repository"
)

// ShowOptions holds show command options.
type ShowOptions struct{}

// ShowDeps holds show dependencies.
type ShowDeps struct {
        CommonDeps
        ArtifactStore repository.ArtifactStore
}

// ShowCommand represents the unit show command.
type ShowCommand struct{}

// NewShowCommand creates a new ShowCommand.
func NewShowCommand() *ShowCommand <span class="cov0" title="0">{
        return &amp;ShowCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *ShowCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for showing unit details.
func (c *ShowCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts ShowOptions

        unitShowCmd := &amp;cobra.Command{
                Use:   "show SERVICE",
                Short: "Show the contents of a service artifact",
                Args:  cobra.ExactArgs(1),
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps, args[0])
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">return unitShowCmd</span>
}

// Run executes the show command with injected dependencies.
func (c *ShowCommand) Run(ctx context.Context, _ *App, _ ShowOptions, deps ShowDeps, serviceName string) error <span class="cov0" title="0">{
        // List all artifacts to find matching service
        artifacts, err := deps.ArtifactStore.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list artifacts: %w", err)
        }</span>

        // Find artifacts matching the service name
        <span class="cov0" title="0">var matchingArtifacts []struct {
                Path    string
                Content string
        }

        for _, artifact := range artifacts </span><span class="cov0" title="0">{
                // Check if artifact matches the service name (handles both systemd and launchd)
                if matchesServiceName(artifact.Path, serviceName) </span><span class="cov0" title="0">{
                        matchingArtifacts = append(matchingArtifacts, struct {
                                Path    string
                                Content string
                        }{
                                Path:    artifact.Path,
                                Content: string(artifact.Content),
                        })
                }</span>
        }

        <span class="cov0" title="0">if len(matchingArtifacts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no artifact found for service %q", serviceName)
        }</span>

        // Display all matching artifacts
        <span class="cov0" title="0">for i, artifact := range matchingArtifacts </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println() // Blank line between artifacts
                }</span>
                <span class="cov0" title="0">fmt.Printf("# Artifact: %s\n", artifact.Path)
                fmt.Println(strings.Repeat("-", 80))
                fmt.Println(artifact.Content)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// buildDeps creates production dependencies for the show command.
func (c *ShowCommand) buildDeps(app *App) ShowDeps <span class="cov0" title="0">{
        return ShowDeps{
                CommonDeps:    NewRootDeps(app),
                ArtifactStore: app.ArtifactStore,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package cmd provides unit command functionality for quad-ops CLI
package cmd

import (
        "context"
        "fmt"

        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/sorting"
)

// StatusOptions holds status command options.
type StatusOptions struct{}

// StatusDeps holds status dependencies.
type StatusDeps struct {
        CommonDeps
}

// StatusCommand represents the unit status command.
type StatusCommand struct{}

// NewStatusCommand creates a new StatusCommand.
func NewStatusCommand() *StatusCommand <span class="cov0" title="0">{
        return &amp;StatusCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *StatusCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for checking unit status.
func (c *StatusCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts StatusOptions

        unitStatusCmd := &amp;cobra.Command{
                Use:   "status SERVICE",
                Short: "Show the status of a service",
                Args:  cobra.ExactArgs(1),
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps, args[0])
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">return unitStatusCmd</span>
}

// Run executes the status command with injected dependencies.
func (c *StatusCommand) Run(ctx context.Context, app *App, _ StatusOptions, deps StatusDeps, serviceName string) error <span class="cov0" title="0">{
        // Validate service name to prevent command injection
        if err := sorting.ValidateUnitName(serviceName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid service name %q: %w", serviceName, err)
        }</span>

        // Get lifecycle from app
        <span class="cov0" title="0">lifecycle, err := app.GetLifecycle(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get lifecycle: %w", err)
        }</span>

        // Get status from Lifecycle
        <span class="cov0" title="0">status, err := lifecycle.Status(ctx, serviceName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get status for service %q: %w", serviceName, err)
        }</span>

        // Display status
        <span class="cov0" title="0">deps.Logger.Info("Service status",
                "service", serviceName,
                "active", status.Active,
                "state", status.State,
                "description", status.Description,
        )

        if status.SubState != "" </span><span class="cov0" title="0">{
                deps.Logger.Info("Substate", "substate", status.SubState)
        }</span>

        <span class="cov0" title="0">if status.Active &amp;&amp; status.PID &gt; 0 </span><span class="cov0" title="0">{
                deps.Logger.Info("Service is running",
                        "pid", status.PID,
                        "since", status.Since,
                )
        }</span>

        <span class="cov0" title="0">if status.Error != "" </span><span class="cov0" title="0">{
                deps.Logger.Error("Service error", "error", status.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildDeps creates production dependencies for the status command.
func (c *StatusCommand) buildDeps(app *App) StatusDeps <span class="cov0" title="0">{
        return StatusDeps{
                CommonDeps: NewRootDeps(app),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/compose"
        "github.com/trly/quad-ops/internal/config"
)

// UpOptions holds up command options.
type UpOptions struct {
        Services []string
        Force    bool
        DryRun   bool
        RepoName string
}

// UpDeps holds up dependencies.
type UpDeps struct {
        CommonDeps
        ComposeProcessor ComposeProcessorInterface
        Renderer         RendererInterface
        ArtifactStore    ArtifactStoreInterface
        Lifecycle        LifecycleInterface
}

// UpCommand represents the up command for quad-ops CLI.
type UpCommand struct{}

// NewUpCommand creates a new UpCommand.
func NewUpCommand() *UpCommand <span class="cov0" title="0">{
        return &amp;UpCommand{}
}</span>

// getApp retrieves the App from the command context.
func (c *UpCommand) getApp(cmd *cobra.Command) *App <span class="cov0" title="0">{
        return cmd.Context().Value(appContextKey).(*App)
}</span>

// GetCobraCommand returns the cobra command for starting managed units.
func (c *UpCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        var opts UpOptions

        upCmd := &amp;cobra.Command{
                Use:   "up",
                Short: "Process compose files and start services",
                Long: `Process Docker Compose files from repositories and start services.

This command orchestrates the full workflow:
1. Process compose files from selected repositories
2. Render service specifications to platform artifacts
3. Write artifacts to disk (with change detection)
4. Reload service manager if changes detected
5. Start the specified services (or all if none specified)

Examples:
  quad-ops up                           # Start all services
  quad-ops up --services web,api        # Start specific services
  quad-ops up --repo my-repo            # Process only one repository
  quad-ops up --dry-run                 # Show what would be done
  quad-ops up --force                   # Force processing even without changes`,
                PreRunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        return app.Validator.SystemRequirements()
                }</span>,
                RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                        app := c.getApp(cmd)
                        deps := c.buildDeps(app)
                        return c.Run(cmd.Context(), app, opts, deps)
                }</span>,
                SilenceUsage:  true,
                SilenceErrors: true,
        }

        <span class="cov0" title="0">upCmd.Flags().StringSliceVar(&amp;opts.Services, "services", nil, "Comma-separated list of services to start")
        upCmd.Flags().BoolVarP(&amp;opts.Force, "force", "f", false, "Force processing even if no changes detected")
        upCmd.Flags().BoolVarP(&amp;opts.DryRun, "dry-run", "d", false, "Show what would be done without making changes")
        upCmd.Flags().StringVarP(&amp;opts.RepoName, "repo", "r", "", "Process only a specific repository")

        return upCmd</span>
}

// buildDeps creates production dependencies for the up command.
// Note: Platform-specific dependencies (Renderer, Lifecycle) are obtained via lazy getters in Run().
func (c *UpCommand) buildDeps(app *App) UpDeps <span class="cov0" title="0">{
        return UpDeps{
                CommonDeps:       NewRootDeps(app),
                ComposeProcessor: app.ComposeProcessor,
                Renderer:         nil, // Obtained via app.GetRenderer(ctx) in Run()
                ArtifactStore:    app.ArtifactStore,
                Lifecycle:        nil, // Obtained via app.GetLifecycle(ctx) in Run()
        }
}</span>

// Run executes the up command with injected dependencies.
// This method orchestrates the workflow: ComposeProcessor → Renderer → ArtifactStore → Lifecycle.
//
//nolint:gocyclo // Orchestration logic requires sequential steps
func (c *UpCommand) Run(ctx context.Context, app *App, opts UpOptions, deps UpDeps) error <span class="cov0" title="0">{
        // Get platform-specific components via lazy getters
        renderer, err := app.GetRenderer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("platform not supported: %w", err)
        }</span>
        <span class="cov0" title="0">deps.Renderer = renderer

        lifecycle, err := app.GetLifecycle(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("platform not supported: %w", err)
        }</span>
        <span class="cov0" title="0">deps.Lifecycle = lifecycle
        // Ensure quadlet directory exists
        if err := deps.FileSystem.MkdirAll(app.Config.QuadletDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create quadlet directory: %w", err)
        }</span>

        // Filter repositories if specific repo requested
        <span class="cov0" title="0">reposToProcess := app.Config.Repositories
        if opts.RepoName != "" </span><span class="cov0" title="0">{
                reposToProcess = make([]config.Repository, 0, 1)
                for _, repo := range app.Config.Repositories </span><span class="cov0" title="0">{
                        if repo.Name == opts.RepoName </span><span class="cov0" title="0">{
                                reposToProcess = append(reposToProcess, repo)
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(reposToProcess) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("repository not found: %s", opts.RepoName)
                }</span>
        }

        // Track all available services from compose processing
        <span class="cov0" title="0">allServices := make(map[string]bool)
        anyChanges := false

        // 1. Process compose files from selected repositories
        for _, repo := range reposToProcess </span><span class="cov0" title="0">{
                deps.Logger.Debug("Processing repository", "repo", repo.Name)

                repoPath := filepath.Join(app.Config.RepositoryDir, repo.Name)

                // Read compose files from repository
                projects, err := compose.ReadProjects(repoPath)
                if err != nil </span><span class="cov0" title="0">{
                        deps.Logger.Error("Failed to read compose projects", "repo", repo.Name, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">if len(projects) == 0 </span><span class="cov0" title="0">{
                        deps.Logger.Debug("No compose projects found", "repo", repo.Name)
                        continue</span>
                }

                // Process all compose projects to service specs
                <span class="cov0" title="0">for _, project := range projects </span><span class="cov0" title="0">{
                        specs, err := deps.ComposeProcessor.Process(ctx, project)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to process compose project",
                                        "repo", repo.Name, "project", project.Name, "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">deps.Logger.Debug("Processed compose project",
                                "repo", repo.Name, "project", project.Name, "services", len(specs))

                        // Track service names
                        for _, spec := range specs </span><span class="cov0" title="0">{
                                allServices[spec.Name] = true
                        }</span>

                        // 2. Render to platform-specific artifacts
                        <span class="cov0" title="0">renderResult, err := deps.Renderer.Render(ctx, specs)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to render artifacts",
                                        "repo", repo.Name, "project", project.Name, "error", err)
                                continue</span>
                        }

                        // Handle dry-run mode
                        <span class="cov0" title="0">if opts.DryRun </span><span class="cov0" title="0">{
                                deps.Logger.Info("Would write artifacts (dry-run)",
                                        "repo", repo.Name, "project", project.Name, "count", len(renderResult.Artifacts))
                                for _, artifact := range renderResult.Artifacts </span><span class="cov0" title="0">{
                                        deps.Logger.Info("  Artifact", "path", artifact.Path)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        // 3. Write artifacts to disk (with change detection)
                        <span class="cov0" title="0">changedPaths, err := deps.ArtifactStore.Write(ctx, renderResult.Artifacts)
                        if err != nil </span><span class="cov0" title="0">{
                                deps.Logger.Error("Failed to write artifacts",
                                        "repo", repo.Name, "project", project.Name, "error", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(changedPaths) &gt; 0 </span><span class="cov0" title="0">{
                                anyChanges = true
                                deps.Logger.Info("Artifacts written",
                                        "repo", repo.Name, "project", project.Name, "changed", len(changedPaths))
                        }</span> else<span class="cov0" title="0"> {
                                deps.Logger.Debug("No artifact changes", "repo", repo.Name, "project", project.Name)
                        }</span>
                }
        }

        // Handle dry-run mode early exit
        <span class="cov0" title="0">if opts.DryRun </span><span class="cov0" title="0">{
                serviceList := make([]string, 0, len(allServices))
                for svc := range allServices </span><span class="cov0" title="0">{
                        serviceList = append(serviceList, svc)
                }</span>
                <span class="cov0" title="0">deps.Logger.Info("Would start services (dry-run)", "services", serviceList)
                return nil</span>
        }

        // 4. Reload service manager if changes detected or forced
        <span class="cov0" title="0">if anyChanges || opts.Force </span><span class="cov0" title="0">{
                deps.Logger.Info("Reloading service manager")
                if err := deps.Lifecycle.Reload(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reload service manager: %w", err)
                }</span>
        }

        // 5. Determine target services (filter by --services flag or all specs)
        <span class="cov0" title="0">var servicesToStart []string
        if len(opts.Services) &gt; 0 </span><span class="cov0" title="0">{
                // Use specified services
                servicesToStart = opts.Services
                // Validate requested services exist
                for _, svc := range servicesToStart </span><span class="cov0" title="0">{
                        if !allServices[svc] </span><span class="cov0" title="0">{
                                deps.Logger.Warn("Requested service not found in compose files", "service", svc)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Start all discovered services
                servicesToStart = make([]string, 0, len(allServices))
                for svc := range allServices </span><span class="cov0" title="0">{
                        servicesToStart = append(servicesToStart, svc)
                }</span>
        }

        <span class="cov0" title="0">if len(servicesToStart) == 0 </span><span class="cov0" title="0">{
                deps.Logger.Info("No services to start")
                return nil
        }</span>

        // 6. Start services using Lifecycle.StartMany
        <span class="cov0" title="0">deps.Logger.Info("Starting services", "count", len(servicesToStart))

        startErrors := deps.Lifecycle.StartMany(ctx, servicesToStart)

        // Log results
        successCount := 0
        failCount := 0
        for serviceName, err := range startErrors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        deps.Logger.Error("Failed to start service", "service", serviceName, "error", err)
                        failCount++
                }</span> else<span class="cov0" title="0"> {
                        deps.Logger.Info("Service started", "service", serviceName)
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">if failCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start %d services", failCount)
        }</span>

        <span class="cov0" title="0">if app.Config.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("Successfully started %d services\n", successCount)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"

        "github.com/creativeprojects/go-selfupdate"
        "github.com/spf13/cobra"
)

// UpdateCommand represents the update command.
type UpdateCommand struct{}

// NewUpdateCommand creates a new UpdateCommand.
func NewUpdateCommand() *UpdateCommand <span class="cov0" title="0">{
        return &amp;UpdateCommand{}
}</span>

// GetCobraCommand returns the cobra command for updating the binary.
func (c *UpdateCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        updateCmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Update quad-ops to the latest version",
                Long:  `Update quad-ops to the latest version from GitHub releases.`,
                RunE: func(_ *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        fmt.Printf("Current version: %s\n", Version)
                        fmt.Println("Checking for updates...")

                        // Detect latest version
                        latest, found, err := selfupdate.DetectLatest(context.Background(), selfupdate.ParseSlug("trly/quad-ops"))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to check for updates: %w", err)
                        }</span>

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                fmt.Println("No release found")
                                return nil
                        }</span>

                        <span class="cov0" title="0">if latest.LessOrEqual(Version) </span><span class="cov0" title="0">{
                                fmt.Println("You are already running the latest version.")
                                return nil
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Update available! New version: %s\n", latest.Version())
                        fmt.Println("Downloading and applying update...")

                        // Get current executable path
                        exe, err := selfupdate.ExecutablePath()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get executable path: %w", err)
                        }</span>

                        // Update to the latest version
                        <span class="cov0" title="0">if err := selfupdate.UpdateTo(context.Background(), latest.AssetURL, latest.AssetName, exe); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Update completed successfully! Please restart %s to use the new version.\n", "quad-ops")
                        return nil</span>
                },
        }

        <span class="cov0" title="0">return updateCmd</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/compose-spec/compose-go/v2/types"
        "github.com/spf13/cobra"
        "github.com/trly/quad-ops/internal/compose"
        "github.com/trly/quad-ops/internal/config"
        "github.com/trly/quad-ops/internal/git"
        "github.com/trly/quad-ops/internal/log"
        "github.com/trly/quad-ops/internal/validate"
)

// ValidateCommand represents the validate command for quad-ops CLI.
type ValidateCommand struct{}

// NewValidateCommand creates a new ValidateCommand.
func NewValidateCommand() *ValidateCommand <span class="cov0" title="0">{
        return &amp;ValidateCommand{}
}</span>

var (
        repoURL              string
        repoRef              string
        composeDir           string
        validatePath         string
        skipClone            bool
        tempDir              string
        checkSysRequirements bool
)

// GetCobraCommand returns the cobra command for validate operations.
func (c *ValidateCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        validateCmd := &amp;cobra.Command{
                Use:   "validate [path]",
                Short: "Validates Docker Compose files and quad-ops extensions in a repository, directory, or single file",
                Long: `Validates Docker Compose files and quad-ops extensions in a repository, directory, or single file.

Can clone a git repository and validate all Docker Compose files within it, validate all 
compose files in a local directory, or validate a single compose file. Perfect for CI/CD 
pipelines and development workflows. The validation checks for:

- Valid Docker Compose file syntax
- Quad-ops extension compatibility 
- Security requirements for secrets and environment variables
- Service dependency graph integrity
- Build configuration validity

Examples:
  # Validate files in current directory
  quad-ops validate

  # Validate files in specific directory  
  quad-ops validate /path/to/compose/files

  # Validate a single compose file (great for CI)
  quad-ops validate docker-compose.yml
  quad-ops validate /path/to/my-service.compose.yml

  # Clone and validate a git repository (use --repo flag, NOT path argument)
  quad-ops validate --repo https://github.com/user/repo.git

  # Clone specific branch/tag and validate
  quad-ops validate --repo https://github.com/user/repo.git --ref main

  # Validate specific compose directory in repository
  quad-ops validate --repo https://github.com/user/repo.git --compose-dir services

Note: Use either a local path OR the --repo flag, but not both.`,

                Args:         cobra.MaximumNArgs(1),
                SilenceUsage: true,
                PreRunE: func(_ *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Determine path to validate
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                validatePath = args[0]
                        }</span> else<span class="cov0" title="0"> if repoURL == "" </span><span class="cov0" title="0">{
                                validatePath = "."
                        }</span>

                        // Validate arguments - make mutually exclusive options clear
                        <span class="cov0" title="0">if repoURL != "" &amp;&amp; len(args) &gt; 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot specify both --repo flag and local path argument")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                RunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                        // Get dependencies from context
                        app := cmd.Context().Value(appContextKey).(*App)
                        logger := app.Logger
                        configProvider := app.ConfigProvider

                        // Check system requirements if requested
                        if checkSysRequirements </span><span class="cov0" title="0">{
                                if err := app.Validator.SystemRequirements(); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("system requirements not met: %w", err)
                                }</span>
                        }

                        <span class="cov0" title="0">var targetPath string
                        var cleanup func() error

                        // Handle repository cloning
                        if repoURL != "" </span><span class="cov0" title="0">{
                                path, cleanupFn, err := cloneRepositoryWithDeps(logger, configProvider)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">targetPath = path
                                cleanup = cleanupFn
                                defer func() </span><span class="cov0" title="0">{
                                        if cleanup != nil </span><span class="cov0" title="0">{
                                                if err := cleanup(); err != nil </span><span class="cov0" title="0">{
                                                        logger.Warn("Failed to cleanup temporary directory", "error", err)
                                                }</span>
                                        }
                                }()
                        } else<span class="cov0" title="0"> {
                                targetPath = validatePath
                        }</span>

                        // Handle compose directory subdirectory
                        <span class="cov0" title="0">if composeDir != "" </span><span class="cov0" title="0">{
                                targetPath = filepath.Join(targetPath, composeDir)
                        }</span>

                        // Validate the path
                        <span class="cov0" title="0">return validateComposeWithDeps(targetPath, logger)</span>
                },
        }

        <span class="cov0" title="0">validateCmd.Flags().StringVar(&amp;repoURL, "repo", "", "Git repository URL to clone and validate")
        validateCmd.Flags().StringVar(&amp;repoRef, "ref", "main", "Git reference (branch/tag/commit) to checkout")
        validateCmd.Flags().StringVar(&amp;composeDir, "compose-dir", "", "Subdirectory within repository containing compose files")
        validateCmd.Flags().BoolVar(&amp;skipClone, "skip-clone", false, "Skip cloning if repository already exists locally")
        validateCmd.Flags().StringVar(&amp;tempDir, "temp-dir", "", "Custom temporary directory for cloning (default: system temp)")
        validateCmd.Flags().BoolVar(&amp;checkSysRequirements, "check-system", false, "Check system requirements (systemd, podman) before validation")

        return validateCmd</span>
}

// cloneRepositoryWithDeps handles git repository cloning and returns the path and cleanup function.
func cloneRepositoryWithDeps(logger log.Logger, configProvider config.Provider) (string, func() error, error) <span class="cov0" title="0">{
        logger.Info("Cloning repository for validation", "url", repoURL, "ref", repoRef)

        // Create temporary repository config for cloning
        repoConfig := config.Repository{
                Name:      "validate-temp",
                URL:       repoURL,
                Reference: repoRef,
        }

        // Create git repository instance
        gitRepo := git.NewGitRepository(repoConfig, configProvider)

        // Override the default path to use a temporary directory with safe naming
        var tempPath string
        if tempDir != "" </span><span class="cov0" title="0">{
                // Ensure we create a subdirectory to prevent accidental deletion of user directory
                tempPath = filepath.Join(tempDir, "quad-ops-validate")
        }</span> else<span class="cov0" title="0"> {
                tempPath = filepath.Join(os.TempDir(), "quad-ops-validate")
        }</span>
        <span class="cov0" title="0">gitRepo.Path = tempPath

        // Validation: ensure the path has our expected suffix for safety
        if !strings.HasSuffix(gitRepo.Path, "quad-ops-validate") </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("invalid temporary path for security reasons: %s", gitRepo.Path)
        }</span>

        // Check if we should skip clone
        <span class="cov0" title="0">if skipClone &amp;&amp; isValidGitRepo(gitRepo.Path) </span><span class="cov0" title="0">{
                logger.Info("Skipping clone, using existing repository", "path", gitRepo.Path)
                return gitRepo.Path, func() error </span><span class="cov0" title="0">{ return nil }</span>, nil
        }

        // Remove existing directory if it exists (only if it ends with our suffix)
        <span class="cov0" title="0">if _, err := os.Stat(gitRepo.Path); err == nil </span><span class="cov0" title="0">{
                if err := os.RemoveAll(gitRepo.Path); err != nil </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("failed to remove existing directory: %w", err)
                }</span>
        }

        // Perform the clone
        <span class="cov0" title="0">if err := gitRepo.SyncRepository(); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to clone repository: %w", err)
        }</span>

        // Return path and cleanup function
        <span class="cov0" title="0">cleanup := func() error </span><span class="cov0" title="0">{
                if !skipClone &amp;&amp; strings.HasSuffix(gitRepo.Path, "quad-ops-validate") </span><span class="cov0" title="0">{
                        return os.RemoveAll(gitRepo.Path)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return gitRepo.Path, cleanup, nil</span>
}

// isValidGitRepo checks if the given path contains a valid git repository.
func isValidGitRepo(path string) bool <span class="cov0" title="0">{
        gitDir := filepath.Join(path, ".git")
        if stat, err := os.Stat(gitDir); err != nil || !stat.IsDir() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// isComposeFile checks if the given path appears to be a YAML file that could be a Docker Compose file.
func isComposeFile(path string) bool <span class="cov0" title="0">{
        ext := filepath.Ext(strings.ToLower(path))
        if ext != ".yml" &amp;&amp; ext != ".yaml" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Quick check: try to read first few lines to see if it looks like a compose file
        <span class="cov0" title="0">file, err := os.Open(filepath.Clean(path)) // #nosec G304 - path is validated upstream
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log error or handle as appropriate - for validation context, we can ignore
                        _ = closeErr
                }</span>
        }()

        // Read first 1KB to check for compose-like content
        <span class="cov0" title="0">buffer := make([]byte, 1024)
        n, _ := file.Read(buffer)
        content := string(buffer[:n])

        // Look for common compose file indicators
        return strings.Contains(content, "services:") ||
                strings.Contains(content, "version:") ||
                strings.Contains(content, "networks:") ||
                strings.Contains(content, "volumes:")</span>
}

// validateComposeWithDeps validates Docker Compose files in the given path (file or directory).
func validateComposeWithDeps(path string, logger log.Logger) error <span class="cov0" title="0">{
        logger.Info("Validating Docker Compose files", "path", path)

        // Check if path exists
        stat, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("path does not exist: %s", path)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to access path: %w", err)
        }</span>

        <span class="cov0" title="0">var projects []*types.Project

        if stat.IsDir() </span><span class="cov0" title="0">{
                // Handle directory - read all compose projects
                projects, err = compose.ReadProjects(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read compose projects: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Handle single file
                if !isComposeFile(path) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file does not appear to be a Docker Compose file: %s", path)
                }</span>

                <span class="cov0" title="0">project, err := compose.ParseComposeFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse compose file: %w", err)
                }</span>

                <span class="cov0" title="0">projects = []*types.Project{project}</span>
        }

        <span class="cov0" title="0">if len(projects) == 0 </span><span class="cov0" title="0">{
                logger.Warn("No Docker Compose files found in path", "path", path)
                return nil
        }</span>

        <span class="cov0" title="0">logger.Debug("Found compose projects for validation", "count", len(projects))

        // Validate each project
        var validationErrors []string
        validProjectCount := 0

        for _, project := range projects </span><span class="cov0" title="0">{
                logger.Info("Validating project", "name", project.Name, "services", len(project.Services), "networks", len(project.Networks), "volumes", len(project.Volumes))

                if err := validateProjectWithDeps(project, logger); err != nil </span><span class="cov0" title="0">{
                        validationErrors = append(validationErrors, fmt.Sprintf("Project %s: %v", project.Name, err))
                        logger.Error("Project validation failed", "project", project.Name, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        validProjectCount++
                        logger.Info("Project validation passed", "project", project.Name)
                }</span>
        }

        // Print summary
        <span class="cov0" title="0">logger.Info("Validation completed",
                "totalProjects", len(projects),
                "validProjects", validProjectCount,
                "errors", len(validationErrors))

        if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Validation Errors:\n")
                for _, err := range validationErrors </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("validation failed with %d errors", len(validationErrors))</span>
        }

        // Success is silent - only show output in verbose mode via logger
        <span class="cov0" title="0">return nil</span>
}

// validateProjectWithDeps validates a single Docker Compose project for quad-ops compatibility.
func validateProjectWithDeps(project *types.Project, logger log.Logger) error <span class="cov0" title="0">{
        validator := validate.NewSecretValidator(logger)

        // Validate services
        for serviceName, service := range project.Services </span><span class="cov0" title="0">{
                if err := validateService(serviceName, service, validator); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("service %s: %w", serviceName, err)
                }</span>
        }

        // Validate networks
        <span class="cov0" title="0">for networkName, network := range project.Networks </span><span class="cov0" title="0">{
                if err := validateNetwork(networkName, network); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("network %s: %w", networkName, err)
                }</span>
        }

        // Validate volumes
        <span class="cov0" title="0">for volumeName, volume := range project.Volumes </span><span class="cov0" title="0">{
                if err := validateVolume(volumeName, volume); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("volume %s: %w", volumeName, err)
                }</span>
        }

        // Validate secrets
        <span class="cov0" title="0">for secretName, secret := range project.Secrets </span><span class="cov0" title="0">{
                if err := validateSecretWithDeps(secretName, secret, validator, logger); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("secret %s: %w", secretName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateService validates a Docker Compose service configuration.
func validateService(_ string, service types.ServiceConfig, validator *validate.SecretValidator) error <span class="cov0" title="0">{
        // Validate environment variables
        for key, value := range service.Environment </span><span class="cov0" title="0">{
                if err := validate.EnvKey(key); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid environment key %s: %w", key, err)
                }</span>

                <span class="cov0" title="0">if value != nil </span><span class="cov0" title="0">{
                        if err := validator.ValidateEnvValue(key, *value); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid environment value for %s: %w", key, err)
                        }</span>
                }
        }

        // Validate secrets
        <span class="cov0" title="0">for _, secretRef := range service.Secrets </span><span class="cov0" title="0">{
                if err := validator.ValidateSecretName(secretRef.Source); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid secret reference %s: %w", secretRef.Source, err)
                }</span>

                <span class="cov0" title="0">if secretRef.Target != "" </span><span class="cov0" title="0">{
                        if err := validator.ValidateSecretTarget(secretRef.Target); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid secret target %s: %w", secretRef.Target, err)
                        }</span>
                }
        }

        // Validate build configuration if present
        <span class="cov0" title="0">if service.Build != nil </span><span class="cov0" title="0">{
                if err := validateBuild(service.Build); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("build configuration: %w", err)
                }</span>
        }

        // Validate init containers (quad-ops extension)
        <span class="cov0" title="0">if err := validateInitContainers(service); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("init containers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateBuild validates Docker Compose build configuration.
func validateBuild(build *types.BuildConfig) error <span class="cov0" title="0">{
        if build.Context == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("build context cannot be empty")
        }</span>

        // Validate build args
        <span class="cov0" title="0">for key, value := range build.Args </span><span class="cov0" title="0">{
                if err := validate.EnvKey(key); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid build arg key %s: %w", key, err)
                }</span>

                <span class="cov0" title="0">if value != nil &amp;&amp; len(*value) &gt; validate.MaxEnvValueSize </span><span class="cov0" title="0">{
                        return fmt.Errorf("build arg value for %s exceeds maximum size (%d bytes, max: %d)",
                                key, len(*value), validate.MaxEnvValueSize)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateInitContainers validates init containers (quad-ops extension).
func validateInitContainers(service types.ServiceConfig) error <span class="cov0" title="0">{
        // Check for init container labels (quad-ops extension)
        initContainerLabels := []string{
                "quad-ops.init-containers",
                "quad-ops.init",
        }

        for _, label := range initContainerLabels </span><span class="cov0" title="0">{
                if value, exists := service.Labels[label]; exists </span><span class="cov0" title="0">{
                        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("init container label %s cannot be empty", label)
                        }</span>
                        // Additional validation could be added here for init container format
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateNetwork validates Docker Compose network configuration.
func validateNetwork(_ string, network types.NetworkConfig) error <span class="cov0" title="0">{
        // Basic network validation
        if bool(network.External) &amp;&amp; network.Driver != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("external networks cannot specify driver")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateVolume validates Docker Compose volume configuration.
func validateVolume(_ string, volume types.VolumeConfig) error <span class="cov0" title="0">{
        // Basic volume validation
        if bool(volume.External) &amp;&amp; volume.Driver != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("external volumes cannot specify driver")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateSecretWithDeps validates Docker Compose secret configuration.
func validateSecretWithDeps(secretName string, secret types.SecretConfig, validator *validate.SecretValidator, logger log.Logger) error <span class="cov0" title="0">{
        if err := validator.ValidateSecretName(secretName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid secret name: %w", err)
        }</span>

        // Validate secret source
        <span class="cov0" title="0">if secret.File != "" </span><span class="cov0" title="0">{
                // Allow relative paths but warn about potential security issues
                if !filepath.IsAbs(secret.File) </span><span class="cov0" title="0">{
                        logger.Debug("Secret uses relative file path", "secret", secretName, "path", secret.File)
                        // Check if path tries to escape current directory
                        if strings.Contains(secret.File, "..") </span><span class="cov0" title="0">{
                                return fmt.Errorf("secret file path contains directory traversal: %s", secret.File)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package cmd provides the command line interface for quad-ops
/*
Copyright © 2025 Travis Lyons travis.lyons@gmail.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package cmd

import (
        "context"
        "fmt"
        "runtime"

        "github.com/creativeprojects/go-selfupdate"
        "github.com/spf13/cobra"
)

// Build information set by goreleaser.
var (
        Version = "dev"
        Commit  = "none"
        Date    = "unknown"
)

// VersionCommand represents the version command.
type VersionCommand struct{}

// NewVersionCommand creates a new VersionCommand.
func NewVersionCommand() *VersionCommand <span class="cov0" title="0">{
        return &amp;VersionCommand{}
}</span>

// GetCobraCommand returns the cobra command for displaying version information.
func (c *VersionCommand) GetCobraCommand() *cobra.Command <span class="cov0" title="0">{
        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Show version information",
                Long:  `Show version information for quad-ops.`,
                Run: func(_ *cobra.Command, _ []string) </span><span class="cov0" title="0">{
                        fmt.Printf("quad-ops version %s\n", Version)
                        fmt.Printf("  commit: %s\n", Commit)
                        fmt.Printf("  built: %s\n", Date)
                        fmt.Printf("  go: %s\n", runtime.Version())

                        // Check for updates
                        c.checkForUpdates()
                }</span>,
        }

        <span class="cov0" title="0">return versionCmd</span>
}

// checkForUpdates checks if a newer version is available and prints a message if so.
func (c *VersionCommand) checkForUpdates() <span class="cov0" title="0">{
        // Skip update check for development builds
        if Version == "dev" </span><span class="cov0" title="0">{
                fmt.Println("\nSkipping update check for development build.")
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("\nChecking for updates...")

        // Detect latest version
        latest, found, err := selfupdate.DetectLatest(context.Background(), selfupdate.ParseSlug("trly/quad-ops"))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to check for updates: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                fmt.Println("No release found")
                return
        }</span>

        <span class="cov0" title="0">if latest.LessOrEqual(Version) </span><span class="cov0" title="0">{
                fmt.Println("You are running the latest version.")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("🚀 Update available! New version: %s\n", latest.Version())
        fmt.Println("Run 'quad-ops update' to update to the latest version.")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
